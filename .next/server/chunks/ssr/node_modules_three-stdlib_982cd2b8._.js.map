{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"NURBSUtils.js","sources":["file:///home/karthickravi/Desktop/website/tech_website/node_modules/src/curves/NURBSUtils.js"],"sourcesContent":["import { Vector3, Vector4 } from 'three'\n\n/**\n * NURBS utils\n *\n * See NURBSCurve and NURBSSurface.\n **/\n\n/**************************************************************\n *\tNURBS Utils\n **************************************************************/\n\n/*\nFinds knot vector span.\n\np : degree\nu : parametric value\nU : knot vector\n\nreturns the span\n*/\nfunction findSpan(p, u, U) {\n  const n = U.length - p - 1\n\n  if (u >= U[n]) {\n    return n - 1\n  }\n\n  if (u <= U[p]) {\n    return p\n  }\n\n  let low = p\n  let high = n\n  let mid = Math.floor((low + high) / 2)\n\n  while (u < U[mid] || u >= U[mid + 1]) {\n    if (u < U[mid]) {\n      high = mid\n    } else {\n      low = mid\n    }\n\n    mid = Math.floor((low + high) / 2)\n  }\n\n  return mid\n}\n\n/*\nCalculate basis functions. See The NURBS Book, page 70, algorithm A2.2\n\nspan : span in which u lies\nu    : parametric point\np    : degree\nU    : knot vector\n\nreturns array[p+1] with basis functions values.\n*/\nfunction calcBasisFunctions(span, u, p, U) {\n  const N = []\n  const left = []\n  const right = []\n  N[0] = 1.0\n\n  for (let j = 1; j <= p; ++j) {\n    left[j] = u - U[span + 1 - j]\n    right[j] = U[span + j] - u\n\n    let saved = 0.0\n\n    for (let r = 0; r < j; ++r) {\n      const rv = right[r + 1]\n      const lv = left[j - r]\n      const temp = N[r] / (rv + lv)\n      N[r] = saved + rv * temp\n      saved = lv * temp\n    }\n\n    N[j] = saved\n  }\n\n  return N\n}\n\n/*\nCalculate B-Spline curve points. See The NURBS Book, page 82, algorithm A3.1.\n\np : degree of B-Spline\nU : knot vector\nP : control points (x, y, z, w)\nu : parametric point\n\nreturns point for given u\n*/\nfunction calcBSplinePoint(p, U, P, u) {\n  const span = findSpan(p, u, U)\n  const N = calcBasisFunctions(span, u, p, U)\n  const C = new Vector4(0, 0, 0, 0)\n\n  for (let j = 0; j <= p; ++j) {\n    const point = P[span - p + j]\n    const Nj = N[j]\n    const wNj = point.w * Nj\n    C.x += point.x * wNj\n    C.y += point.y * wNj\n    C.z += point.z * wNj\n    C.w += point.w * Nj\n  }\n\n  return C\n}\n\n/*\nCalculate basis functions derivatives. See The NURBS Book, page 72, algorithm A2.3.\n\nspan : span in which u lies\nu    : parametric point\np    : degree\nn    : number of derivatives to calculate\nU    : knot vector\n\nreturns array[n+1][p+1] with basis functions derivatives\n*/\nfunction calcBasisFunctionDerivatives(span, u, p, n, U) {\n  const zeroArr = []\n  for (let i = 0; i <= p; ++i) zeroArr[i] = 0.0\n\n  const ders = []\n\n  for (let i = 0; i <= n; ++i) ders[i] = zeroArr.slice(0)\n\n  const ndu = []\n\n  for (let i = 0; i <= p; ++i) ndu[i] = zeroArr.slice(0)\n\n  ndu[0][0] = 1.0\n\n  const left = zeroArr.slice(0)\n  const right = zeroArr.slice(0)\n\n  for (let j = 1; j <= p; ++j) {\n    left[j] = u - U[span + 1 - j]\n    right[j] = U[span + j] - u\n\n    let saved = 0.0\n\n    for (let r = 0; r < j; ++r) {\n      const rv = right[r + 1]\n      const lv = left[j - r]\n      ndu[j][r] = rv + lv\n\n      const temp = ndu[r][j - 1] / ndu[j][r]\n      ndu[r][j] = saved + rv * temp\n      saved = lv * temp\n    }\n\n    ndu[j][j] = saved\n  }\n\n  for (let j = 0; j <= p; ++j) {\n    ders[0][j] = ndu[j][p]\n  }\n\n  for (let r = 0; r <= p; ++r) {\n    let s1 = 0\n    let s2 = 1\n\n    const a = []\n    for (let i = 0; i <= p; ++i) {\n      a[i] = zeroArr.slice(0)\n    }\n\n    a[0][0] = 1.0\n\n    for (let k = 1; k <= n; ++k) {\n      let d = 0.0\n      const rk = r - k\n      const pk = p - k\n\n      if (r >= k) {\n        a[s2][0] = a[s1][0] / ndu[pk + 1][rk]\n        d = a[s2][0] * ndu[rk][pk]\n      }\n\n      const j1 = rk >= -1 ? 1 : -rk\n      const j2 = r - 1 <= pk ? k - 1 : p - r\n\n      for (let j = j1; j <= j2; ++j) {\n        a[s2][j] = (a[s1][j] - a[s1][j - 1]) / ndu[pk + 1][rk + j]\n        d += a[s2][j] * ndu[rk + j][pk]\n      }\n\n      if (r <= pk) {\n        a[s2][k] = -a[s1][k - 1] / ndu[pk + 1][r]\n        d += a[s2][k] * ndu[r][pk]\n      }\n\n      ders[k][r] = d\n\n      const j = s1\n      s1 = s2\n      s2 = j\n    }\n  }\n\n  let r = p\n\n  for (let k = 1; k <= n; ++k) {\n    for (let j = 0; j <= p; ++j) {\n      ders[k][j] *= r\n    }\n\n    r *= p - k\n  }\n\n  return ders\n}\n\n/*\n\tCalculate derivatives of a B-Spline. See The NURBS Book, page 93, algorithm A3.2.\n\n\tp  : degree\n\tU  : knot vector\n\tP  : control points\n\tu  : Parametric points\n\tnd : number of derivatives\n\n\treturns array[d+1] with derivatives\n\t*/\nfunction calcBSplineDerivatives(p, U, P, u, nd) {\n  const du = nd < p ? nd : p\n  const CK = []\n  const span = findSpan(p, u, U)\n  const nders = calcBasisFunctionDerivatives(span, u, p, du, U)\n  const Pw = []\n\n  for (let i = 0; i < P.length; ++i) {\n    const point = P[i].clone()\n    const w = point.w\n\n    point.x *= w\n    point.y *= w\n    point.z *= w\n\n    Pw[i] = point\n  }\n\n  for (let k = 0; k <= du; ++k) {\n    const point = Pw[span - p].clone().multiplyScalar(nders[k][0])\n\n    for (let j = 1; j <= p; ++j) {\n      point.add(Pw[span - p + j].clone().multiplyScalar(nders[k][j]))\n    }\n\n    CK[k] = point\n  }\n\n  for (let k = du + 1; k <= nd + 1; ++k) {\n    CK[k] = new Vector4(0, 0, 0)\n  }\n\n  return CK\n}\n\n/*\nCalculate \"K over I\"\n\nreturns k!/(i!(k-i)!)\n*/\nfunction calcKoverI(k, i) {\n  let nom = 1\n\n  for (let j = 2; j <= k; ++j) {\n    nom *= j\n  }\n\n  let denom = 1\n\n  for (let j = 2; j <= i; ++j) {\n    denom *= j\n  }\n\n  for (let j = 2; j <= k - i; ++j) {\n    denom *= j\n  }\n\n  return nom / denom\n}\n\n/*\nCalculate derivatives (0-nd) of rational curve. See The NURBS Book, page 127, algorithm A4.2.\n\nPders : result of function calcBSplineDerivatives\n\nreturns array with derivatives for rational curve.\n*/\nfunction calcRationalCurveDerivatives(Pders) {\n  const nd = Pders.length\n  const Aders = []\n  const wders = []\n\n  for (let i = 0; i < nd; ++i) {\n    const point = Pders[i]\n    Aders[i] = new Vector3(point.x, point.y, point.z)\n    wders[i] = point.w\n  }\n\n  const CK = []\n\n  for (let k = 0; k < nd; ++k) {\n    const v = Aders[k].clone()\n\n    for (let i = 1; i <= k; ++i) {\n      v.sub(CK[k - i].clone().multiplyScalar(calcKoverI(k, i) * wders[i]))\n    }\n\n    CK[k] = v.divideScalar(wders[0])\n  }\n\n  return CK\n}\n\n/*\nCalculate NURBS curve derivatives. See The NURBS Book, page 127, algorithm A4.2.\n\np  : degree\nU  : knot vector\nP  : control points in homogeneous space\nu  : parametric points\nnd : number of derivatives\n\nreturns array with derivatives.\n*/\nfunction calcNURBSDerivatives(p, U, P, u, nd) {\n  const Pders = calcBSplineDerivatives(p, U, P, u, nd)\n  return calcRationalCurveDerivatives(Pders)\n}\n\n/*\nCalculate rational B-Spline surface point. See The NURBS Book, page 134, algorithm A4.3.\n\np1, p2 : degrees of B-Spline surface\nU1, U2 : knot vectors\nP      : control points (x, y, z, w)\nu, v   : parametric values\n\nreturns point for given (u, v)\n*/\nfunction calcSurfacePoint(p, q, U, V, P, u, v, target) {\n  const uspan = findSpan(p, u, U)\n  const vspan = findSpan(q, v, V)\n  const Nu = calcBasisFunctions(uspan, u, p, U)\n  const Nv = calcBasisFunctions(vspan, v, q, V)\n  const temp = []\n\n  for (let l = 0; l <= q; ++l) {\n    temp[l] = new Vector4(0, 0, 0, 0)\n    for (let k = 0; k <= p; ++k) {\n      const point = P[uspan - p + k][vspan - q + l].clone()\n      const w = point.w\n      point.x *= w\n      point.y *= w\n      point.z *= w\n      temp[l].add(point.multiplyScalar(Nu[k]))\n    }\n  }\n\n  const Sw = new Vector4(0, 0, 0, 0)\n  for (let l = 0; l <= q; ++l) {\n    Sw.add(temp[l].multiplyScalar(Nv[l]))\n  }\n\n  Sw.divideScalar(Sw.w)\n  target.set(Sw.x, Sw.y, Sw.z)\n}\n\nexport {\n  findSpan,\n  calcBasisFunctions,\n  calcBSplinePoint,\n  calcBasisFunctionDerivatives,\n  calcBSplineDerivatives,\n  calcKoverI,\n  calcRationalCurveDerivatives,\n  calcNURBSDerivatives,\n  calcSurfacePoint,\n}\n"],"names":["r","j"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 239, "column": 0}, "map": {"version":3,"file":"NURBSCurve.js","sources":["file:///home/karthickravi/Desktop/website/tech_website/node_modules/src/curves/NURBSCurve.js"],"sourcesContent":["import { Curve, Vector3, Vector4 } from 'three'\nimport * as NURBSUtils from '../curves/NURBSUtils'\n\n/**\n * NURBS curve object\n *\n * Derives from Curve, overriding getPoint and getTangent.\n *\n * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\n *\n **/\n\nclass NURBSCurve extends Curve {\n  constructor(\n    degree,\n    knots /* array of reals */,\n    controlPoints /* array of Vector(2|3|4) */,\n    startKnot /* index in knots */,\n    endKnot /* index in knots */,\n  ) {\n    super()\n\n    this.degree = degree\n    this.knots = knots\n    this.controlPoints = []\n    // Used by periodic NURBS to remove hidden spans\n    this.startKnot = startKnot || 0\n    this.endKnot = endKnot || this.knots.length - 1\n    for (let i = 0; i < controlPoints.length; ++i) {\n      // ensure Vector4 for control points\n      const point = controlPoints[i]\n      this.controlPoints[i] = new Vector4(point.x, point.y, point.z, point.w)\n    }\n  }\n\n  getPoint(t, optionalTarget) {\n    const point = optionalTarget || new Vector3()\n\n    const u = this.knots[this.startKnot] + t * (this.knots[this.endKnot] - this.knots[this.startKnot]) // linear mapping t->u\n\n    // following results in (wx, wy, wz, w) homogeneous point\n    const hpoint = NURBSUtils.calcBSplinePoint(this.degree, this.knots, this.controlPoints, u)\n\n    if (hpoint.w != 1.0) {\n      // project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)\n      hpoint.divideScalar(hpoint.w)\n    }\n\n    return point.set(hpoint.x, hpoint.y, hpoint.z)\n  }\n\n  getTangent(t, optionalTarget) {\n    const tangent = optionalTarget || new Vector3()\n\n    const u = this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0])\n    const ders = NURBSUtils.calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, u, 1)\n    tangent.copy(ders[1]).normalize()\n\n    return tangent\n  }\n}\n\nexport { NURBSCurve }\n"],"names":["NURBSUtils.calcBSplinePoint","NURBSUtils.calcNURBSDerivatives"],"mappings":";;;;;;;AAYA,MAAM,mKAAmB,QAAA,CAAM;IAC7B,YACE,MAAA,EACA,KAAA,EACA,aAAA,EACA,SAAA,EACA,OAAA,CACA;QACA,KAAA,CAAO;QAEP,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,KAAA,GAAQ;QACb,IAAA,CAAK,aAAA,GAAgB,CAAE,CAAA;QAEvB,IAAA,CAAK,SAAA,GAAY,aAAa;QAC9B,IAAA,CAAK,OAAA,GAAU,WAAW,IAAA,CAAK,KAAA,CAAM,MAAA,GAAS;QAC9C,IAAA,IAAS,IAAI,GAAG,IAAI,cAAc,MAAA,EAAQ,EAAE,EAAG;YAE7C,MAAM,QAAQ,aAAA,CAAc,CAAC,CAAA;YAC7B,IAAA,CAAK,aAAA,CAAc,CAAC,CAAA,GAAI,oJAAI,UAAA,CAAQ,MAAM,CAAA,EAAG,MAAM,CAAA,EAAG,MAAM,CAAA,EAAG,MAAM,CAAC;QACvE;IACF;IAED,SAAS,CAAA,EAAG,cAAA,EAAgB;QAC1B,MAAM,QAAQ,kBAAkB,oJAAI,UAAA,CAAS;QAE7C,MAAM,IAAI,IAAA,CAAK,KAAA,CAAM,IAAA,CAAK,SAAS,CAAA,GAAI,IAAA,CAAK,IAAA,CAAK,KAAA,CAAM,IAAA,CAAK,OAAO,CAAA,GAAI,IAAA,CAAK,KAAA,CAAM,IAAA,CAAK,SAAS,CAAA;QAGhG,MAAM,qKAASA,mBAAAA,EAA4B,IAAA,CAAK,MAAA,EAAQ,IAAA,CAAK,KAAA,EAAO,IAAA,CAAK,aAAA,EAAe,CAAC;QAEzF,IAAI,OAAO,CAAA,IAAK,GAAK;YAEnB,OAAO,YAAA,CAAa,OAAO,CAAC;QAC7B;QAED,OAAO,MAAM,GAAA,CAAI,OAAO,CAAA,EAAG,OAAO,CAAA,EAAG,OAAO,CAAC;IAC9C;IAED,WAAW,CAAA,EAAG,cAAA,EAAgB;QAC5B,MAAM,UAAU,kBAAkB,oJAAI,UAAA,CAAS;QAE/C,MAAM,IAAI,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA,GAAI,IAAA,CAAK,IAAA,CAAK,KAAA,CAAM,IAAA,CAAK,KAAA,CAAM,MAAA,GAAS,CAAC,CAAA,GAAI,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA;QAC/E,MAAM,mKAAOC,uBAAAA,EAAgC,IAAA,CAAK,MAAA,EAAQ,IAAA,CAAK,KAAA,EAAO,IAAA,CAAK,aAAA,EAAe,GAAG,CAAC;QAC9F,QAAQ,IAAA,CAAK,IAAA,CAAK,CAAC,CAAC,EAAE,SAAA,CAAW;QAEjC,OAAO;IACR;AACH","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 284, "column": 0}, "map": {"version":3,"file":"LoaderUtils.js","sources":["file:///home/karthickravi/Desktop/website/tech_website/node_modules/src/_polyfill/LoaderUtils.js"],"sourcesContent":["export function decodeText(array) {\n  if (typeof TextDecoder !== 'undefined') {\n    return new TextDecoder().decode(array)\n  }\n\n  // Avoid the String.fromCharCode.apply(null, array) shortcut, which\n  // throws a \"maximum call stack size exceeded\" error for large arrays.\n\n  let s = ''\n\n  for (let i = 0, il = array.length; i < il; i++) {\n    // Implicitly assumes little-endian.\n    s += String.fromCharCode(array[i])\n  }\n\n  try {\n    // merges multi-byte utf-8 characters.\n\n    return decodeURIComponent(escape(s))\n  } catch (e) {\n    // see https://github.com/mrdoob/three.js/issues/16358\n\n    return s\n  }\n}\n"],"names":[],"mappings":";;;AAAO,SAAS,WAAW,KAAA,EAAO;IAChC,IAAI,OAAO,gBAAgB,aAAa;QACtC,OAAO,IAAI,YAAW,EAAG,MAAA,CAAO,KAAK;IACtC;IAKD,IAAI,IAAI;IAER,IAAA,IAAS,IAAI,GAAG,KAAK,MAAM,MAAA,EAAQ,IAAI,IAAI,IAAK;QAE9C,KAAK,OAAO,YAAA,CAAa,KAAA,CAAM,CAAC,CAAC;IAClC;IAED,IAAI;QAGF,OAAO,mBAAmB,OAAO,CAAC,CAAC;IACpC,EAAA,OAAQ,GAAP;QAGA,OAAO;IACR;AACH","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 309, "column": 0}, "map": {"version":3,"file":"constants.js","sources":["file:///home/karthickravi/Desktop/website/tech_website/node_modules/src/_polyfill/constants.ts"],"sourcesContent":["import { REVISION } from 'three'\n\nexport const version = /* @__PURE__ */ (() => parseInt(REVISION.replace(/\\D+/g, '')))()\n"],"names":[],"mappings":";;;;;AAEa,MAAA,UAAA,aAAA,GAAA,CAAA,IAAiC,yJAAS,WAAA,CAAS,OAAA,CAAQ,QAAQ,EAAE,CAAC,CAAA,EAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 323, "column": 0}, "map": {"version":3,"file":"uv1.js","sources":["file:///home/karthickravi/Desktop/website/tech_website/node_modules/src/_polyfill/uv1.ts"],"sourcesContent":["import { version } from \"./constants\";\n\n/** uv2 renamed to uv1 in r125\n * \n * https://github.com/mrdoob/three.js/pull/25943\n*/\nexport const UV1 = version >= 125 ? 'uv1' : 'uv2'"],"names":[],"mappings":";;;;;AAMa,MAAA,gKAAM,UAAA,IAAW,MAAM,QAAQ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 337, "column": 0}, "map": {"version":3,"file":"FBXLoader.js","sources":["file:///home/karthickravi/Desktop/website/tech_website/node_modules/src/loaders/FBXLoader.js"],"sourcesContent":["import {\n  AmbientLight,\n  AnimationClip,\n  Bone,\n  BufferGeometry,\n  ClampToEdgeWrapping,\n  Color,\n  DirectionalLight,\n  EquirectangularReflectionMapping,\n  Euler,\n  FileLoader,\n  Float32BufferAttribute,\n  Group,\n  Line,\n  LineBasicMaterial,\n  Loader,\n  LoaderUtils,\n  MathUtils,\n  Matrix3,\n  Matrix4,\n  Mesh,\n  MeshLambertMaterial,\n  MeshPhongMaterial,\n  NumberKeyframeTrack,\n  Object3D,\n  OrthographicCamera,\n  PerspectiveCamera,\n  PointLight,\n  PropertyBinding,\n  Quaternion,\n  QuaternionKeyframeTrack,\n  RepeatWrapping,\n  Skeleton,\n  SkinnedMesh,\n  SpotLight,\n  Texture,\n  TextureLoader,\n  Uint16BufferAttribute,\n  Vector3,\n  Vector4,\n  VectorKeyframeTrack,\n} from 'three'\nimport { unzlibSync } from 'fflate'\nimport { NURBSCurve } from '../curves/NURBSCurve'\nimport { decodeText } from '../_polyfill/LoaderUtils'\nimport { UV1 } from '../_polyfill/uv1'\n\n/**\n * Loader loads FBX file and generates Group representing FBX scene.\n * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format\n * Versions lower than this may load but will probably have errors\n *\n * Needs Support:\n *  Morph normals / blend shape normals\n *\n * FBX format references:\n * \thttps://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)\n *\n * Binary format specification:\n *\thttps://code.blender.org/2013/08/fbx-binary-file-format-specification/\n */\n\nlet fbxTree\nlet connections\nlet sceneGraph\n\nclass FBXLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path\n\n    const loader = new FileLoader(this.manager)\n    loader.setPath(scope.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n\n    loader.load(\n      url,\n      function (buffer) {\n        try {\n          onLoad(scope.parse(buffer, path))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(FBXBuffer, path) {\n    if (isFbxFormatBinary(FBXBuffer)) {\n      fbxTree = new BinaryParser().parse(FBXBuffer)\n    } else {\n      const FBXText = convertArrayBufferToString(FBXBuffer)\n\n      if (!isFbxFormatASCII(FBXText)) {\n        throw new Error('THREE.FBXLoader: Unknown format.')\n      }\n\n      if (getFbxVersion(FBXText) < 7000) {\n        throw new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion(FBXText))\n      }\n\n      fbxTree = new TextParser().parse(FBXText)\n    }\n\n    // console.log( fbxTree );\n\n    const textureLoader = new TextureLoader(this.manager)\n      .setPath(this.resourcePath || path)\n      .setCrossOrigin(this.crossOrigin)\n\n    return new FBXTreeParser(textureLoader, this.manager).parse(fbxTree)\n  }\n}\n\n// Parse the FBXTree object returned by the BinaryParser or TextParser and return a Group\nclass FBXTreeParser {\n  constructor(textureLoader, manager) {\n    this.textureLoader = textureLoader\n    this.manager = manager\n  }\n\n  parse() {\n    connections = this.parseConnections()\n\n    const images = this.parseImages()\n    const textures = this.parseTextures(images)\n    const materials = this.parseMaterials(textures)\n    const deformers = this.parseDeformers()\n    const geometryMap = new GeometryParser().parse(deformers)\n\n    this.parseScene(deformers, geometryMap, materials)\n\n    return sceneGraph\n  }\n\n  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\n  // and details the connection type\n  parseConnections() {\n    const connectionMap = new Map()\n\n    if ('Connections' in fbxTree) {\n      const rawConnections = fbxTree.Connections.connections\n\n      rawConnections.forEach(function (rawConnection) {\n        const fromID = rawConnection[0]\n        const toID = rawConnection[1]\n        const relationship = rawConnection[2]\n\n        if (!connectionMap.has(fromID)) {\n          connectionMap.set(fromID, {\n            parents: [],\n            children: [],\n          })\n        }\n\n        const parentRelationship = { ID: toID, relationship: relationship }\n        connectionMap.get(fromID).parents.push(parentRelationship)\n\n        if (!connectionMap.has(toID)) {\n          connectionMap.set(toID, {\n            parents: [],\n            children: [],\n          })\n        }\n\n        const childRelationship = { ID: fromID, relationship: relationship }\n        connectionMap.get(toID).children.push(childRelationship)\n      })\n    }\n\n    return connectionMap\n  }\n\n  // Parse FBXTree.Objects.Video for embedded image data\n  // These images are connected to textures in FBXTree.Objects.Textures\n  // via FBXTree.Connections.\n  parseImages() {\n    const images = {}\n    const blobs = {}\n\n    if ('Video' in fbxTree.Objects) {\n      const videoNodes = fbxTree.Objects.Video\n\n      for (const nodeID in videoNodes) {\n        const videoNode = videoNodes[nodeID]\n\n        const id = parseInt(nodeID)\n\n        images[id] = videoNode.RelativeFilename || videoNode.Filename\n\n        // raw image data is in videoNode.Content\n        if ('Content' in videoNode) {\n          const arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0\n          const base64Content = typeof videoNode.Content === 'string' && videoNode.Content !== ''\n\n          if (arrayBufferContent || base64Content) {\n            const image = this.parseImage(videoNodes[nodeID])\n\n            blobs[videoNode.RelativeFilename || videoNode.Filename] = image\n          }\n        }\n      }\n    }\n\n    for (const id in images) {\n      const filename = images[id]\n\n      if (blobs[filename] !== undefined) images[id] = blobs[filename]\n      else images[id] = images[id].split('\\\\').pop()\n    }\n\n    return images\n  }\n\n  // Parse embedded image data in FBXTree.Video.Content\n  parseImage(videoNode) {\n    const content = videoNode.Content\n    const fileName = videoNode.RelativeFilename || videoNode.Filename\n    const extension = fileName.slice(fileName.lastIndexOf('.') + 1).toLowerCase()\n\n    let type\n\n    switch (extension) {\n      case 'bmp':\n        type = 'image/bmp'\n        break\n\n      case 'jpg':\n      case 'jpeg':\n        type = 'image/jpeg'\n        break\n\n      case 'png':\n        type = 'image/png'\n        break\n\n      case 'tif':\n        type = 'image/tiff'\n        break\n\n      case 'tga':\n        if (this.manager.getHandler('.tga') === null) {\n          console.warn('FBXLoader: TGA loader not found, skipping ', fileName)\n        }\n\n        type = 'image/tga'\n        break\n\n      default:\n        console.warn('FBXLoader: Image type \"' + extension + '\" is not supported.')\n        return\n    }\n\n    if (typeof content === 'string') {\n      // ASCII format\n\n      return 'data:' + type + ';base64,' + content\n    } else {\n      // Binary Format\n\n      const array = new Uint8Array(content)\n      return window.URL.createObjectURL(new Blob([array], { type: type }))\n    }\n  }\n\n  // Parse nodes in FBXTree.Objects.Texture\n  // These contain details such as UV scaling, cropping, rotation etc and are connected\n  // to images in FBXTree.Objects.Video\n  parseTextures(images) {\n    const textureMap = new Map()\n\n    if ('Texture' in fbxTree.Objects) {\n      const textureNodes = fbxTree.Objects.Texture\n      for (const nodeID in textureNodes) {\n        const texture = this.parseTexture(textureNodes[nodeID], images)\n        textureMap.set(parseInt(nodeID), texture)\n      }\n    }\n\n    return textureMap\n  }\n\n  // Parse individual node in FBXTree.Objects.Texture\n  parseTexture(textureNode, images) {\n    const texture = this.loadTexture(textureNode, images)\n\n    texture.ID = textureNode.id\n\n    texture.name = textureNode.attrName\n\n    const wrapModeU = textureNode.WrapModeU\n    const wrapModeV = textureNode.WrapModeV\n\n    const valueU = wrapModeU !== undefined ? wrapModeU.value : 0\n    const valueV = wrapModeV !== undefined ? wrapModeV.value : 0\n\n    // http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\n    // 0: repeat(default), 1: clamp\n\n    texture.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping\n    texture.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping\n\n    if ('Scaling' in textureNode) {\n      const values = textureNode.Scaling.value\n\n      texture.repeat.x = values[0]\n      texture.repeat.y = values[1]\n    }\n\n    return texture\n  }\n\n  // load a texture specified as a blob or data URI, or via an external URL using TextureLoader\n  loadTexture(textureNode, images) {\n    let fileName\n\n    const currentPath = this.textureLoader.path\n\n    const children = connections.get(textureNode.id).children\n\n    if (children !== undefined && children.length > 0 && images[children[0].ID] !== undefined) {\n      fileName = images[children[0].ID]\n\n      if (fileName.indexOf('blob:') === 0 || fileName.indexOf('data:') === 0) {\n        this.textureLoader.setPath(undefined)\n      }\n    }\n\n    let texture\n\n    const extension = textureNode.FileName.slice(-3).toLowerCase()\n\n    if (extension === 'tga') {\n      const loader = this.manager.getHandler('.tga')\n\n      if (loader === null) {\n        console.warn('FBXLoader: TGA loader not found, creating placeholder texture for', textureNode.RelativeFilename)\n        texture = new Texture()\n      } else {\n        loader.setPath(this.textureLoader.path)\n        texture = loader.load(fileName)\n      }\n    } else if (extension === 'psd') {\n      console.warn(\n        'FBXLoader: PSD textures are not supported, creating placeholder texture for',\n        textureNode.RelativeFilename,\n      )\n      texture = new Texture()\n    } else {\n      texture = this.textureLoader.load(fileName)\n    }\n\n    this.textureLoader.setPath(currentPath)\n\n    return texture\n  }\n\n  // Parse nodes in FBXTree.Objects.Material\n  parseMaterials(textureMap) {\n    const materialMap = new Map()\n\n    if ('Material' in fbxTree.Objects) {\n      const materialNodes = fbxTree.Objects.Material\n\n      for (const nodeID in materialNodes) {\n        const material = this.parseMaterial(materialNodes[nodeID], textureMap)\n\n        if (material !== null) materialMap.set(parseInt(nodeID), material)\n      }\n    }\n\n    return materialMap\n  }\n\n  // Parse single node in FBXTree.Objects.Material\n  // Materials are connected to texture maps in FBXTree.Objects.Textures\n  // FBX format currently only supports Lambert and Phong shading models\n  parseMaterial(materialNode, textureMap) {\n    const ID = materialNode.id\n    const name = materialNode.attrName\n    let type = materialNode.ShadingModel\n\n    // Case where FBX wraps shading model in property object.\n    if (typeof type === 'object') {\n      type = type.value\n    }\n\n    // Ignore unused materials which don't have any connections.\n    if (!connections.has(ID)) return null\n\n    const parameters = this.parseParameters(materialNode, textureMap, ID)\n\n    let material\n\n    switch (type.toLowerCase()) {\n      case 'phong':\n        material = new MeshPhongMaterial()\n        break\n      case 'lambert':\n        material = new MeshLambertMaterial()\n        break\n      default:\n        console.warn('THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type)\n        material = new MeshPhongMaterial()\n        break\n    }\n\n    material.setValues(parameters)\n    material.name = name\n\n    return material\n  }\n\n  // Parse FBX material and return parameters suitable for a three.js material\n  // Also parse the texture map and return any textures associated with the material\n  parseParameters(materialNode, textureMap, ID) {\n    const parameters = {}\n\n    if (materialNode.BumpFactor) {\n      parameters.bumpScale = materialNode.BumpFactor.value\n    }\n\n    if (materialNode.Diffuse) {\n      parameters.color = new Color().fromArray(materialNode.Diffuse.value)\n    } else if (\n      materialNode.DiffuseColor &&\n      (materialNode.DiffuseColor.type === 'Color' || materialNode.DiffuseColor.type === 'ColorRGB')\n    ) {\n      // The blender exporter exports diffuse here instead of in materialNode.Diffuse\n      parameters.color = new Color().fromArray(materialNode.DiffuseColor.value)\n    }\n\n    if (materialNode.DisplacementFactor) {\n      parameters.displacementScale = materialNode.DisplacementFactor.value\n    }\n\n    if (materialNode.Emissive) {\n      parameters.emissive = new Color().fromArray(materialNode.Emissive.value)\n    } else if (\n      materialNode.EmissiveColor &&\n      (materialNode.EmissiveColor.type === 'Color' || materialNode.EmissiveColor.type === 'ColorRGB')\n    ) {\n      // The blender exporter exports emissive color here instead of in materialNode.Emissive\n      parameters.emissive = new Color().fromArray(materialNode.EmissiveColor.value)\n    }\n\n    if (materialNode.EmissiveFactor) {\n      parameters.emissiveIntensity = parseFloat(materialNode.EmissiveFactor.value)\n    }\n\n    if (materialNode.Opacity) {\n      parameters.opacity = parseFloat(materialNode.Opacity.value)\n    }\n\n    if (parameters.opacity < 1.0) {\n      parameters.transparent = true\n    }\n\n    if (materialNode.ReflectionFactor) {\n      parameters.reflectivity = materialNode.ReflectionFactor.value\n    }\n\n    if (materialNode.Shininess) {\n      parameters.shininess = materialNode.Shininess.value\n    }\n\n    if (materialNode.Specular) {\n      parameters.specular = new Color().fromArray(materialNode.Specular.value)\n    } else if (materialNode.SpecularColor && materialNode.SpecularColor.type === 'Color') {\n      // The blender exporter exports specular color here instead of in materialNode.Specular\n      parameters.specular = new Color().fromArray(materialNode.SpecularColor.value)\n    }\n\n    const scope = this\n    connections.get(ID).children.forEach(function (child) {\n      const type = child.relationship\n\n      switch (type) {\n        case 'Bump':\n          parameters.bumpMap = scope.getTexture(textureMap, child.ID)\n          break\n\n        case 'Maya|TEX_ao_map':\n          parameters.aoMap = scope.getTexture(textureMap, child.ID)\n          break\n\n        case 'DiffuseColor':\n        case 'Maya|TEX_color_map':\n          parameters.map = scope.getTexture(textureMap, child.ID)\n          if (parameters.map !== undefined) {\n            if ('colorSpace' in parameters.map) parameters.map.colorSpace = 'srgb'\n            else parameters.map.encoding = 3001 // sRGBEncoding\n          }\n\n          break\n\n        case 'DisplacementColor':\n          parameters.displacementMap = scope.getTexture(textureMap, child.ID)\n          break\n\n        case 'EmissiveColor':\n          parameters.emissiveMap = scope.getTexture(textureMap, child.ID)\n          if (parameters.emissiveMap !== undefined) {\n            if ('colorSpace' in parameters.emissiveMap) parameters.emissiveMap.colorSpace = 'srgb'\n            else parameters.emissiveMap.encoding = 3001 // sRGBEncoding\n          }\n\n          break\n\n        case 'NormalMap':\n        case 'Maya|TEX_normal_map':\n          parameters.normalMap = scope.getTexture(textureMap, child.ID)\n          break\n\n        case 'ReflectionColor':\n          parameters.envMap = scope.getTexture(textureMap, child.ID)\n          if (parameters.envMap !== undefined) {\n            parameters.envMap.mapping = EquirectangularReflectionMapping\n\n            if ('colorSpace' in parameters.envMap) parameters.envMap.colorSpace = 'srgb'\n            else parameters.envMap.encoding = 3001 // sRGBEncoding\n          }\n\n          break\n\n        case 'SpecularColor':\n          parameters.specularMap = scope.getTexture(textureMap, child.ID)\n          if (parameters.specularMap !== undefined) {\n            if ('colorSpace' in parameters.specularMap) parameters.specularMap.colorSpace = 'srgb'\n            else parameters.specularMap.encoding = 3001 // sRGBEncoding\n          }\n\n          break\n\n        case 'TransparentColor':\n        case 'TransparencyFactor':\n          parameters.alphaMap = scope.getTexture(textureMap, child.ID)\n          parameters.transparent = true\n          break\n\n        case 'AmbientColor':\n        case 'ShininessExponent': // AKA glossiness map\n        case 'SpecularFactor': // AKA specularLevel\n        case 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor\n        default:\n          console.warn('THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type)\n          break\n      }\n    })\n\n    return parameters\n  }\n\n  // get a texture from the textureMap for use by a material.\n  getTexture(textureMap, id) {\n    // if the texture is a layered texture, just use the first layer and issue a warning\n    if ('LayeredTexture' in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture) {\n      console.warn('THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.')\n      id = connections.get(id).children[0].ID\n    }\n\n    return textureMap.get(id)\n  }\n\n  // Parse nodes in FBXTree.Objects.Deformer\n  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\n  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.\n  parseDeformers() {\n    const skeletons = {}\n    const morphTargets = {}\n\n    if ('Deformer' in fbxTree.Objects) {\n      const DeformerNodes = fbxTree.Objects.Deformer\n\n      for (const nodeID in DeformerNodes) {\n        const deformerNode = DeformerNodes[nodeID]\n\n        const relationships = connections.get(parseInt(nodeID))\n\n        if (deformerNode.attrType === 'Skin') {\n          const skeleton = this.parseSkeleton(relationships, DeformerNodes)\n          skeleton.ID = nodeID\n\n          if (relationships.parents.length > 1) {\n            console.warn('THREE.FBXLoader: skeleton attached to more than one geometry is not supported.')\n          }\n          skeleton.geometryID = relationships.parents[0].ID\n\n          skeletons[nodeID] = skeleton\n        } else if (deformerNode.attrType === 'BlendShape') {\n          const morphTarget = {\n            id: nodeID,\n          }\n\n          morphTarget.rawTargets = this.parseMorphTargets(relationships, DeformerNodes)\n          morphTarget.id = nodeID\n\n          if (relationships.parents.length > 1) {\n            console.warn('THREE.FBXLoader: morph target attached to more than one geometry is not supported.')\n          }\n\n          morphTargets[nodeID] = morphTarget\n        }\n      }\n    }\n\n    return {\n      skeletons: skeletons,\n      morphTargets: morphTargets,\n    }\n  }\n\n  // Parse single nodes in FBXTree.Objects.Deformer\n  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\n  // Each skin node represents a skeleton and each cluster node represents a bone\n  parseSkeleton(relationships, deformerNodes) {\n    const rawBones = []\n\n    relationships.children.forEach(function (child) {\n      const boneNode = deformerNodes[child.ID]\n\n      if (boneNode.attrType !== 'Cluster') return\n\n      const rawBone = {\n        ID: child.ID,\n        indices: [],\n        weights: [],\n        transformLink: new Matrix4().fromArray(boneNode.TransformLink.a),\n        // transform: new Matrix4().fromArray( boneNode.Transform.a ),\n        // linkMode: boneNode.Mode,\n      }\n\n      if ('Indexes' in boneNode) {\n        rawBone.indices = boneNode.Indexes.a\n        rawBone.weights = boneNode.Weights.a\n      }\n\n      rawBones.push(rawBone)\n    })\n\n    return {\n      rawBones: rawBones,\n      bones: [],\n    }\n  }\n\n  // The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\"\n  parseMorphTargets(relationships, deformerNodes) {\n    const rawMorphTargets = []\n\n    for (let i = 0; i < relationships.children.length; i++) {\n      const child = relationships.children[i]\n\n      const morphTargetNode = deformerNodes[child.ID]\n\n      const rawMorphTarget = {\n        name: morphTargetNode.attrName,\n        initialWeight: morphTargetNode.DeformPercent,\n        id: morphTargetNode.id,\n        fullWeights: morphTargetNode.FullWeights.a,\n      }\n\n      if (morphTargetNode.attrType !== 'BlendShapeChannel') return\n\n      rawMorphTarget.geoID = connections.get(parseInt(child.ID)).children.filter(function (child) {\n        return child.relationship === undefined\n      })[0].ID\n\n      rawMorphTargets.push(rawMorphTarget)\n    }\n\n    return rawMorphTargets\n  }\n\n  // create the main Group() to be returned by the loader\n  parseScene(deformers, geometryMap, materialMap) {\n    sceneGraph = new Group()\n\n    const modelMap = this.parseModels(deformers.skeletons, geometryMap, materialMap)\n\n    const modelNodes = fbxTree.Objects.Model\n\n    const scope = this\n    modelMap.forEach(function (model) {\n      const modelNode = modelNodes[model.ID]\n      scope.setLookAtProperties(model, modelNode)\n\n      const parentConnections = connections.get(model.ID).parents\n\n      parentConnections.forEach(function (connection) {\n        const parent = modelMap.get(connection.ID)\n        if (parent !== undefined) parent.add(model)\n      })\n\n      if (model.parent === null) {\n        sceneGraph.add(model)\n      }\n    })\n\n    this.bindSkeleton(deformers.skeletons, geometryMap, modelMap)\n\n    this.createAmbientLight()\n\n    sceneGraph.traverse(function (node) {\n      if (node.userData.transformData) {\n        if (node.parent) {\n          node.userData.transformData.parentMatrix = node.parent.matrix\n          node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld\n        }\n\n        const transform = generateTransform(node.userData.transformData)\n\n        node.applyMatrix4(transform)\n        node.updateWorldMatrix()\n      }\n    })\n\n    const animations = new AnimationParser().parse()\n\n    // if all the models where already combined in a single group, just return that\n    if (sceneGraph.children.length === 1 && sceneGraph.children[0].isGroup) {\n      sceneGraph.children[0].animations = animations\n      sceneGraph = sceneGraph.children[0]\n    }\n\n    sceneGraph.animations = animations\n  }\n\n  // parse nodes in FBXTree.Objects.Model\n  parseModels(skeletons, geometryMap, materialMap) {\n    const modelMap = new Map()\n    const modelNodes = fbxTree.Objects.Model\n\n    for (const nodeID in modelNodes) {\n      const id = parseInt(nodeID)\n      const node = modelNodes[nodeID]\n      const relationships = connections.get(id)\n\n      let model = this.buildSkeleton(relationships, skeletons, id, node.attrName)\n\n      if (!model) {\n        switch (node.attrType) {\n          case 'Camera':\n            model = this.createCamera(relationships)\n            break\n          case 'Light':\n            model = this.createLight(relationships)\n            break\n          case 'Mesh':\n            model = this.createMesh(relationships, geometryMap, materialMap)\n            break\n          case 'NurbsCurve':\n            model = this.createCurve(relationships, geometryMap)\n            break\n          case 'LimbNode':\n          case 'Root':\n            model = new Bone()\n            break\n          case 'Null':\n          default:\n            model = new Group()\n            break\n        }\n\n        model.name = node.attrName ? PropertyBinding.sanitizeNodeName(node.attrName) : ''\n\n        model.ID = id\n      }\n\n      this.getTransformData(model, node)\n      modelMap.set(id, model)\n    }\n\n    return modelMap\n  }\n\n  buildSkeleton(relationships, skeletons, id, name) {\n    let bone = null\n\n    relationships.parents.forEach(function (parent) {\n      for (const ID in skeletons) {\n        const skeleton = skeletons[ID]\n\n        skeleton.rawBones.forEach(function (rawBone, i) {\n          if (rawBone.ID === parent.ID) {\n            const subBone = bone\n            bone = new Bone()\n\n            bone.matrixWorld.copy(rawBone.transformLink)\n\n            // set name and id here - otherwise in cases where \"subBone\" is created it will not have a name / id\n\n            bone.name = name ? PropertyBinding.sanitizeNodeName(name) : ''\n            bone.ID = id\n\n            skeleton.bones[i] = bone\n\n            // In cases where a bone is shared between multiple meshes\n            // duplicate the bone here and and it as a child of the first bone\n            if (subBone !== null) {\n              bone.add(subBone)\n            }\n          }\n        })\n      }\n    })\n\n    return bone\n  }\n\n  // create a PerspectiveCamera or OrthographicCamera\n  createCamera(relationships) {\n    let model\n    let cameraAttribute\n\n    relationships.children.forEach(function (child) {\n      const attr = fbxTree.Objects.NodeAttribute[child.ID]\n\n      if (attr !== undefined) {\n        cameraAttribute = attr\n      }\n    })\n\n    if (cameraAttribute === undefined) {\n      model = new Object3D()\n    } else {\n      let type = 0\n      if (cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1) {\n        type = 1\n      }\n\n      let nearClippingPlane = 1\n      if (cameraAttribute.NearPlane !== undefined) {\n        nearClippingPlane = cameraAttribute.NearPlane.value / 1000\n      }\n\n      let farClippingPlane = 1000\n      if (cameraAttribute.FarPlane !== undefined) {\n        farClippingPlane = cameraAttribute.FarPlane.value / 1000\n      }\n\n      let width = window.innerWidth\n      let height = window.innerHeight\n\n      if (cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined) {\n        width = cameraAttribute.AspectWidth.value\n        height = cameraAttribute.AspectHeight.value\n      }\n\n      const aspect = width / height\n\n      let fov = 45\n      if (cameraAttribute.FieldOfView !== undefined) {\n        fov = cameraAttribute.FieldOfView.value\n      }\n\n      const focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null\n\n      switch (type) {\n        case 0: // Perspective\n          model = new PerspectiveCamera(fov, aspect, nearClippingPlane, farClippingPlane)\n          if (focalLength !== null) model.setFocalLength(focalLength)\n          break\n\n        case 1: // Orthographic\n          model = new OrthographicCamera(\n            -width / 2,\n            width / 2,\n            height / 2,\n            -height / 2,\n            nearClippingPlane,\n            farClippingPlane,\n          )\n          break\n\n        default:\n          console.warn('THREE.FBXLoader: Unknown camera type ' + type + '.')\n          model = new Object3D()\n          break\n      }\n    }\n\n    return model\n  }\n\n  // Create a DirectionalLight, PointLight or SpotLight\n  createLight(relationships) {\n    let model\n    let lightAttribute\n\n    relationships.children.forEach(function (child) {\n      const attr = fbxTree.Objects.NodeAttribute[child.ID]\n\n      if (attr !== undefined) {\n        lightAttribute = attr\n      }\n    })\n\n    if (lightAttribute === undefined) {\n      model = new Object3D()\n    } else {\n      let type\n\n      // LightType can be undefined for Point lights\n      if (lightAttribute.LightType === undefined) {\n        type = 0\n      } else {\n        type = lightAttribute.LightType.value\n      }\n\n      let color = 0xffffff\n\n      if (lightAttribute.Color !== undefined) {\n        color = new Color().fromArray(lightAttribute.Color.value)\n      }\n\n      let intensity = lightAttribute.Intensity === undefined ? 1 : lightAttribute.Intensity.value / 100\n\n      // light disabled\n      if (lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0) {\n        intensity = 0\n      }\n\n      let distance = 0\n      if (lightAttribute.FarAttenuationEnd !== undefined) {\n        if (lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0) {\n          distance = 0\n        } else {\n          distance = lightAttribute.FarAttenuationEnd.value\n        }\n      }\n\n      // TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?\n      const decay = 1\n\n      switch (type) {\n        case 0: // Point\n          model = new PointLight(color, intensity, distance, decay)\n          break\n\n        case 1: // Directional\n          model = new DirectionalLight(color, intensity)\n          break\n\n        case 2: // Spot\n          let angle = Math.PI / 3\n\n          if (lightAttribute.InnerAngle !== undefined) {\n            angle = MathUtils.degToRad(lightAttribute.InnerAngle.value)\n          }\n\n          let penumbra = 0\n          if (lightAttribute.OuterAngle !== undefined) {\n            // TODO: this is not correct - FBX calculates outer and inner angle in degrees\n            // with OuterAngle > InnerAngle && OuterAngle <= Math.PI\n            // while three.js uses a penumbra between (0, 1) to attenuate the inner angle\n            penumbra = MathUtils.degToRad(lightAttribute.OuterAngle.value)\n            penumbra = Math.max(penumbra, 1)\n          }\n\n          model = new SpotLight(color, intensity, distance, angle, penumbra, decay)\n          break\n\n        default:\n          console.warn(\n            'THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a PointLight.',\n          )\n          model = new PointLight(color, intensity)\n          break\n      }\n\n      if (lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1) {\n        model.castShadow = true\n      }\n    }\n\n    return model\n  }\n\n  createMesh(relationships, geometryMap, materialMap) {\n    let model\n    let geometry = null\n    let material = null\n    const materials = []\n\n    // get geometry and materials(s) from connections\n    relationships.children.forEach(function (child) {\n      if (geometryMap.has(child.ID)) {\n        geometry = geometryMap.get(child.ID)\n      }\n\n      if (materialMap.has(child.ID)) {\n        materials.push(materialMap.get(child.ID))\n      }\n    })\n\n    if (materials.length > 1) {\n      material = materials\n    } else if (materials.length > 0) {\n      material = materials[0]\n    } else {\n      material = new MeshPhongMaterial({ color: 0xcccccc })\n      materials.push(material)\n    }\n\n    if ('color' in geometry.attributes) {\n      materials.forEach(function (material) {\n        material.vertexColors = true\n      })\n    }\n\n    if (geometry.FBX_Deformer) {\n      model = new SkinnedMesh(geometry, material)\n      model.normalizeSkinWeights()\n    } else {\n      model = new Mesh(geometry, material)\n    }\n\n    return model\n  }\n\n  createCurve(relationships, geometryMap) {\n    const geometry = relationships.children.reduce(function (geo, child) {\n      if (geometryMap.has(child.ID)) geo = geometryMap.get(child.ID)\n\n      return geo\n    }, null)\n\n    // FBX does not list materials for Nurbs lines, so we'll just put our own in here.\n    const material = new LineBasicMaterial({ color: 0x3300ff, linewidth: 1 })\n    return new Line(geometry, material)\n  }\n\n  // parse the model node for transform data\n  getTransformData(model, modelNode) {\n    const transformData = {}\n\n    if ('InheritType' in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value)\n\n    if ('RotationOrder' in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value)\n    else transformData.eulerOrder = 'ZYX'\n\n    if ('Lcl_Translation' in modelNode) transformData.translation = modelNode.Lcl_Translation.value\n\n    if ('PreRotation' in modelNode) transformData.preRotation = modelNode.PreRotation.value\n    if ('Lcl_Rotation' in modelNode) transformData.rotation = modelNode.Lcl_Rotation.value\n    if ('PostRotation' in modelNode) transformData.postRotation = modelNode.PostRotation.value\n\n    if ('Lcl_Scaling' in modelNode) transformData.scale = modelNode.Lcl_Scaling.value\n\n    if ('ScalingOffset' in modelNode) transformData.scalingOffset = modelNode.ScalingOffset.value\n    if ('ScalingPivot' in modelNode) transformData.scalingPivot = modelNode.ScalingPivot.value\n\n    if ('RotationOffset' in modelNode) transformData.rotationOffset = modelNode.RotationOffset.value\n    if ('RotationPivot' in modelNode) transformData.rotationPivot = modelNode.RotationPivot.value\n\n    model.userData.transformData = transformData\n  }\n\n  setLookAtProperties(model, modelNode) {\n    if ('LookAtProperty' in modelNode) {\n      const children = connections.get(model.ID).children\n\n      children.forEach(function (child) {\n        if (child.relationship === 'LookAtProperty') {\n          const lookAtTarget = fbxTree.Objects.Model[child.ID]\n\n          if ('Lcl_Translation' in lookAtTarget) {\n            const pos = lookAtTarget.Lcl_Translation.value\n\n            // DirectionalLight, SpotLight\n            if (model.target !== undefined) {\n              model.target.position.fromArray(pos)\n              sceneGraph.add(model.target)\n            } else {\n              // Cameras and other Object3Ds\n\n              model.lookAt(new Vector3().fromArray(pos))\n            }\n          }\n        }\n      })\n    }\n  }\n\n  bindSkeleton(skeletons, geometryMap, modelMap) {\n    const bindMatrices = this.parsePoseNodes()\n\n    for (const ID in skeletons) {\n      const skeleton = skeletons[ID]\n\n      const parents = connections.get(parseInt(skeleton.ID)).parents\n\n      parents.forEach(function (parent) {\n        if (geometryMap.has(parent.ID)) {\n          const geoID = parent.ID\n          const geoRelationships = connections.get(geoID)\n\n          geoRelationships.parents.forEach(function (geoConnParent) {\n            if (modelMap.has(geoConnParent.ID)) {\n              const model = modelMap.get(geoConnParent.ID)\n\n              model.bind(new Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID])\n            }\n          })\n        }\n      })\n    }\n  }\n\n  parsePoseNodes() {\n    const bindMatrices = {}\n\n    if ('Pose' in fbxTree.Objects) {\n      const BindPoseNode = fbxTree.Objects.Pose\n\n      for (const nodeID in BindPoseNode) {\n        if (BindPoseNode[nodeID].attrType === 'BindPose' && BindPoseNode[nodeID].NbPoseNodes > 0) {\n          const poseNodes = BindPoseNode[nodeID].PoseNode\n\n          if (Array.isArray(poseNodes)) {\n            poseNodes.forEach(function (poseNode) {\n              bindMatrices[poseNode.Node] = new Matrix4().fromArray(poseNode.Matrix.a)\n            })\n          } else {\n            bindMatrices[poseNodes.Node] = new Matrix4().fromArray(poseNodes.Matrix.a)\n          }\n        }\n      }\n    }\n\n    return bindMatrices\n  }\n\n  // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light\n  createAmbientLight() {\n    if ('GlobalSettings' in fbxTree && 'AmbientColor' in fbxTree.GlobalSettings) {\n      const ambientColor = fbxTree.GlobalSettings.AmbientColor.value\n      const r = ambientColor[0]\n      const g = ambientColor[1]\n      const b = ambientColor[2]\n\n      if (r !== 0 || g !== 0 || b !== 0) {\n        const color = new Color(r, g, b)\n        sceneGraph.add(new AmbientLight(color, 1))\n      }\n    }\n  }\n}\n\n// parse Geometry data from FBXTree and return map of BufferGeometries\nclass GeometryParser {\n  // Parse nodes in FBXTree.Objects.Geometry\n  parse(deformers) {\n    const geometryMap = new Map()\n\n    if ('Geometry' in fbxTree.Objects) {\n      const geoNodes = fbxTree.Objects.Geometry\n\n      for (const nodeID in geoNodes) {\n        const relationships = connections.get(parseInt(nodeID))\n        const geo = this.parseGeometry(relationships, geoNodes[nodeID], deformers)\n\n        geometryMap.set(parseInt(nodeID), geo)\n      }\n    }\n\n    return geometryMap\n  }\n\n  // Parse single node in FBXTree.Objects.Geometry\n  parseGeometry(relationships, geoNode, deformers) {\n    switch (geoNode.attrType) {\n      case 'Mesh':\n        return this.parseMeshGeometry(relationships, geoNode, deformers)\n        break\n\n      case 'NurbsCurve':\n        return this.parseNurbsGeometry(geoNode)\n        break\n    }\n  }\n\n  // Parse single node mesh geometry in FBXTree.Objects.Geometry\n  parseMeshGeometry(relationships, geoNode, deformers) {\n    const skeletons = deformers.skeletons\n    const morphTargets = []\n\n    const modelNodes = relationships.parents.map(function (parent) {\n      return fbxTree.Objects.Model[parent.ID]\n    })\n\n    // don't create geometry if it is not associated with any models\n    if (modelNodes.length === 0) return\n\n    const skeleton = relationships.children.reduce(function (skeleton, child) {\n      if (skeletons[child.ID] !== undefined) skeleton = skeletons[child.ID]\n\n      return skeleton\n    }, null)\n\n    relationships.children.forEach(function (child) {\n      if (deformers.morphTargets[child.ID] !== undefined) {\n        morphTargets.push(deformers.morphTargets[child.ID])\n      }\n    })\n\n    // Assume one model and get the preRotation from that\n    // if there is more than one model associated with the geometry this may cause problems\n    const modelNode = modelNodes[0]\n\n    const transformData = {}\n\n    if ('RotationOrder' in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value)\n    if ('InheritType' in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value)\n\n    if ('GeometricTranslation' in modelNode) transformData.translation = modelNode.GeometricTranslation.value\n    if ('GeometricRotation' in modelNode) transformData.rotation = modelNode.GeometricRotation.value\n    if ('GeometricScaling' in modelNode) transformData.scale = modelNode.GeometricScaling.value\n\n    const transform = generateTransform(transformData)\n\n    return this.genGeometry(geoNode, skeleton, morphTargets, transform)\n  }\n\n  // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry\n  genGeometry(geoNode, skeleton, morphTargets, preTransform) {\n    const geo = new BufferGeometry()\n    if (geoNode.attrName) geo.name = geoNode.attrName\n\n    const geoInfo = this.parseGeoNode(geoNode, skeleton)\n    const buffers = this.genBuffers(geoInfo)\n\n    const positionAttribute = new Float32BufferAttribute(buffers.vertex, 3)\n\n    positionAttribute.applyMatrix4(preTransform)\n\n    geo.setAttribute('position', positionAttribute)\n\n    if (buffers.colors.length > 0) {\n      geo.setAttribute('color', new Float32BufferAttribute(buffers.colors, 3))\n    }\n\n    if (skeleton) {\n      geo.setAttribute('skinIndex', new Uint16BufferAttribute(buffers.weightsIndices, 4))\n\n      geo.setAttribute('skinWeight', new Float32BufferAttribute(buffers.vertexWeights, 4))\n\n      // used later to bind the skeleton to the model\n      geo.FBX_Deformer = skeleton\n    }\n\n    if (buffers.normal.length > 0) {\n      const normalMatrix = new Matrix3().getNormalMatrix(preTransform)\n\n      const normalAttribute = new Float32BufferAttribute(buffers.normal, 3)\n      normalAttribute.applyNormalMatrix(normalMatrix)\n\n      geo.setAttribute('normal', normalAttribute)\n    }\n\n    buffers.uvs.forEach(function (uvBuffer, i) {\n      if (UV1 === 'uv2') i++\n      const name = i === 0 ? 'uv' : `uv${i}`\n\n      geo.setAttribute(name, new Float32BufferAttribute(buffers.uvs[i], 2))\n    })\n\n    if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n      // Convert the material indices of each vertex into rendering groups on the geometry.\n      let prevMaterialIndex = buffers.materialIndex[0]\n      let startIndex = 0\n\n      buffers.materialIndex.forEach(function (currentIndex, i) {\n        if (currentIndex !== prevMaterialIndex) {\n          geo.addGroup(startIndex, i - startIndex, prevMaterialIndex)\n\n          prevMaterialIndex = currentIndex\n          startIndex = i\n        }\n      })\n\n      // the loop above doesn't add the last group, do that here.\n      if (geo.groups.length > 0) {\n        const lastGroup = geo.groups[geo.groups.length - 1]\n        const lastIndex = lastGroup.start + lastGroup.count\n\n        if (lastIndex !== buffers.materialIndex.length) {\n          geo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex)\n        }\n      }\n\n      // case where there are multiple materials but the whole geometry is only\n      // using one of them\n      if (geo.groups.length === 0) {\n        geo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0])\n      }\n    }\n\n    this.addMorphTargets(geo, geoNode, morphTargets, preTransform)\n\n    return geo\n  }\n\n  parseGeoNode(geoNode, skeleton) {\n    const geoInfo = {}\n\n    geoInfo.vertexPositions = geoNode.Vertices !== undefined ? geoNode.Vertices.a : []\n    geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== undefined ? geoNode.PolygonVertexIndex.a : []\n\n    if (geoNode.LayerElementColor) {\n      geoInfo.color = this.parseVertexColors(geoNode.LayerElementColor[0])\n    }\n\n    if (geoNode.LayerElementMaterial) {\n      geoInfo.material = this.parseMaterialIndices(geoNode.LayerElementMaterial[0])\n    }\n\n    if (geoNode.LayerElementNormal) {\n      geoInfo.normal = this.parseNormals(geoNode.LayerElementNormal[0])\n    }\n\n    if (geoNode.LayerElementUV) {\n      geoInfo.uv = []\n\n      let i = 0\n      while (geoNode.LayerElementUV[i]) {\n        if (geoNode.LayerElementUV[i].UV) {\n          geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i]))\n        }\n\n        i++\n      }\n    }\n\n    geoInfo.weightTable = {}\n\n    if (skeleton !== null) {\n      geoInfo.skeleton = skeleton\n\n      skeleton.rawBones.forEach(function (rawBone, i) {\n        // loop over the bone's vertex indices and weights\n        rawBone.indices.forEach(function (index, j) {\n          if (geoInfo.weightTable[index] === undefined) geoInfo.weightTable[index] = []\n\n          geoInfo.weightTable[index].push({\n            id: i,\n            weight: rawBone.weights[j],\n          })\n        })\n      })\n    }\n\n    return geoInfo\n  }\n\n  genBuffers(geoInfo) {\n    const buffers = {\n      vertex: [],\n      normal: [],\n      colors: [],\n      uvs: [],\n      materialIndex: [],\n      vertexWeights: [],\n      weightsIndices: [],\n    }\n\n    let polygonIndex = 0\n    let faceLength = 0\n    let displayedWeightsWarning = false\n\n    // these will hold data for a single face\n    let facePositionIndexes = []\n    let faceNormals = []\n    let faceColors = []\n    let faceUVs = []\n    let faceWeights = []\n    let faceWeightIndices = []\n\n    const scope = this\n    geoInfo.vertexIndices.forEach(function (vertexIndex, polygonVertexIndex) {\n      let materialIndex\n      let endOfFace = false\n\n      // Face index and vertex index arrays are combined in a single array\n      // A cube with quad faces looks like this:\n      // PolygonVertexIndex: *24 {\n      //  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5\n      //  }\n      // Negative numbers mark the end of a face - first face here is 0, 1, 3, -3\n      // to find index of last vertex bit shift the index: ^ - 1\n      if (vertexIndex < 0) {\n        vertexIndex = vertexIndex ^ -1 // equivalent to ( x * -1 ) - 1\n        endOfFace = true\n      }\n\n      let weightIndices = []\n      let weights = []\n\n      facePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2)\n\n      if (geoInfo.color) {\n        const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color)\n\n        faceColors.push(data[0], data[1], data[2])\n      }\n\n      if (geoInfo.skeleton) {\n        if (geoInfo.weightTable[vertexIndex] !== undefined) {\n          geoInfo.weightTable[vertexIndex].forEach(function (wt) {\n            weights.push(wt.weight)\n            weightIndices.push(wt.id)\n          })\n        }\n\n        if (weights.length > 4) {\n          if (!displayedWeightsWarning) {\n            console.warn(\n              'THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.',\n            )\n            displayedWeightsWarning = true\n          }\n\n          const wIndex = [0, 0, 0, 0]\n          const Weight = [0, 0, 0, 0]\n\n          weights.forEach(function (weight, weightIndex) {\n            let currentWeight = weight\n            let currentIndex = weightIndices[weightIndex]\n\n            Weight.forEach(function (comparedWeight, comparedWeightIndex, comparedWeightArray) {\n              if (currentWeight > comparedWeight) {\n                comparedWeightArray[comparedWeightIndex] = currentWeight\n                currentWeight = comparedWeight\n\n                const tmp = wIndex[comparedWeightIndex]\n                wIndex[comparedWeightIndex] = currentIndex\n                currentIndex = tmp\n              }\n            })\n          })\n\n          weightIndices = wIndex\n          weights = Weight\n        }\n\n        // if the weight array is shorter than 4 pad with 0s\n        while (weights.length < 4) {\n          weights.push(0)\n          weightIndices.push(0)\n        }\n\n        for (let i = 0; i < 4; ++i) {\n          faceWeights.push(weights[i])\n          faceWeightIndices.push(weightIndices[i])\n        }\n      }\n\n      if (geoInfo.normal) {\n        const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal)\n\n        faceNormals.push(data[0], data[1], data[2])\n      }\n\n      if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n        materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0]\n      }\n\n      if (geoInfo.uv) {\n        geoInfo.uv.forEach(function (uv, i) {\n          const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv)\n\n          if (faceUVs[i] === undefined) {\n            faceUVs[i] = []\n          }\n\n          faceUVs[i].push(data[0])\n          faceUVs[i].push(data[1])\n        })\n      }\n\n      faceLength++\n\n      if (endOfFace) {\n        scope.genFace(\n          buffers,\n          geoInfo,\n          facePositionIndexes,\n          materialIndex,\n          faceNormals,\n          faceColors,\n          faceUVs,\n          faceWeights,\n          faceWeightIndices,\n          faceLength,\n        )\n\n        polygonIndex++\n        faceLength = 0\n\n        // reset arrays for the next face\n        facePositionIndexes = []\n        faceNormals = []\n        faceColors = []\n        faceUVs = []\n        faceWeights = []\n        faceWeightIndices = []\n      }\n    })\n\n    return buffers\n  }\n\n  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\n  genFace(\n    buffers,\n    geoInfo,\n    facePositionIndexes,\n    materialIndex,\n    faceNormals,\n    faceColors,\n    faceUVs,\n    faceWeights,\n    faceWeightIndices,\n    faceLength,\n  ) {\n    for (let i = 2; i < faceLength; i++) {\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]])\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]])\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]])\n\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3]])\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 1]])\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 2]])\n\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3]])\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 1]])\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 2]])\n\n      if (geoInfo.skeleton) {\n        buffers.vertexWeights.push(faceWeights[0])\n        buffers.vertexWeights.push(faceWeights[1])\n        buffers.vertexWeights.push(faceWeights[2])\n        buffers.vertexWeights.push(faceWeights[3])\n\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4])\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 1])\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 2])\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 3])\n\n        buffers.vertexWeights.push(faceWeights[i * 4])\n        buffers.vertexWeights.push(faceWeights[i * 4 + 1])\n        buffers.vertexWeights.push(faceWeights[i * 4 + 2])\n        buffers.vertexWeights.push(faceWeights[i * 4 + 3])\n\n        buffers.weightsIndices.push(faceWeightIndices[0])\n        buffers.weightsIndices.push(faceWeightIndices[1])\n        buffers.weightsIndices.push(faceWeightIndices[2])\n        buffers.weightsIndices.push(faceWeightIndices[3])\n\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4])\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 1])\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 2])\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 3])\n\n        buffers.weightsIndices.push(faceWeightIndices[i * 4])\n        buffers.weightsIndices.push(faceWeightIndices[i * 4 + 1])\n        buffers.weightsIndices.push(faceWeightIndices[i * 4 + 2])\n        buffers.weightsIndices.push(faceWeightIndices[i * 4 + 3])\n      }\n\n      if (geoInfo.color) {\n        buffers.colors.push(faceColors[0])\n        buffers.colors.push(faceColors[1])\n        buffers.colors.push(faceColors[2])\n\n        buffers.colors.push(faceColors[(i - 1) * 3])\n        buffers.colors.push(faceColors[(i - 1) * 3 + 1])\n        buffers.colors.push(faceColors[(i - 1) * 3 + 2])\n\n        buffers.colors.push(faceColors[i * 3])\n        buffers.colors.push(faceColors[i * 3 + 1])\n        buffers.colors.push(faceColors[i * 3 + 2])\n      }\n\n      if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n        buffers.materialIndex.push(materialIndex)\n        buffers.materialIndex.push(materialIndex)\n        buffers.materialIndex.push(materialIndex)\n      }\n\n      if (geoInfo.normal) {\n        buffers.normal.push(faceNormals[0])\n        buffers.normal.push(faceNormals[1])\n        buffers.normal.push(faceNormals[2])\n\n        buffers.normal.push(faceNormals[(i - 1) * 3])\n        buffers.normal.push(faceNormals[(i - 1) * 3 + 1])\n        buffers.normal.push(faceNormals[(i - 1) * 3 + 2])\n\n        buffers.normal.push(faceNormals[i * 3])\n        buffers.normal.push(faceNormals[i * 3 + 1])\n        buffers.normal.push(faceNormals[i * 3 + 2])\n      }\n\n      if (geoInfo.uv) {\n        geoInfo.uv.forEach(function (uv, j) {\n          if (buffers.uvs[j] === undefined) buffers.uvs[j] = []\n\n          buffers.uvs[j].push(faceUVs[j][0])\n          buffers.uvs[j].push(faceUVs[j][1])\n\n          buffers.uvs[j].push(faceUVs[j][(i - 1) * 2])\n          buffers.uvs[j].push(faceUVs[j][(i - 1) * 2 + 1])\n\n          buffers.uvs[j].push(faceUVs[j][i * 2])\n          buffers.uvs[j].push(faceUVs[j][i * 2 + 1])\n        })\n      }\n    }\n  }\n\n  addMorphTargets(parentGeo, parentGeoNode, morphTargets, preTransform) {\n    if (morphTargets.length === 0) return\n\n    parentGeo.morphTargetsRelative = true\n\n    parentGeo.morphAttributes.position = []\n    // parentGeo.morphAttributes.normal = []; // not implemented\n\n    const scope = this\n    morphTargets.forEach(function (morphTarget) {\n      morphTarget.rawTargets.forEach(function (rawTarget) {\n        const morphGeoNode = fbxTree.Objects.Geometry[rawTarget.geoID]\n\n        if (morphGeoNode !== undefined) {\n          scope.genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name)\n        }\n      })\n    })\n  }\n\n  // a morph geometry node is similar to a standard  node, and the node is also contained\n  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\n  // and a special attribute Index defining which vertices of the original geometry are affected\n  // Normal and position attributes only have data for the vertices that are affected by the morph\n  genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, name) {\n    const vertexIndices = parentGeoNode.PolygonVertexIndex !== undefined ? parentGeoNode.PolygonVertexIndex.a : []\n\n    const morphPositionsSparse = morphGeoNode.Vertices !== undefined ? morphGeoNode.Vertices.a : []\n    const indices = morphGeoNode.Indexes !== undefined ? morphGeoNode.Indexes.a : []\n\n    const length = parentGeo.attributes.position.count * 3\n    const morphPositions = new Float32Array(length)\n\n    for (let i = 0; i < indices.length; i++) {\n      const morphIndex = indices[i] * 3\n\n      morphPositions[morphIndex] = morphPositionsSparse[i * 3]\n      morphPositions[morphIndex + 1] = morphPositionsSparse[i * 3 + 1]\n      morphPositions[morphIndex + 2] = morphPositionsSparse[i * 3 + 2]\n    }\n\n    // TODO: add morph normal support\n    const morphGeoInfo = {\n      vertexIndices: vertexIndices,\n      vertexPositions: morphPositions,\n    }\n\n    const morphBuffers = this.genBuffers(morphGeoInfo)\n\n    const positionAttribute = new Float32BufferAttribute(morphBuffers.vertex, 3)\n    positionAttribute.name = name || morphGeoNode.attrName\n\n    positionAttribute.applyMatrix4(preTransform)\n\n    parentGeo.morphAttributes.position.push(positionAttribute)\n  }\n\n  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\n  parseNormals(NormalNode) {\n    const mappingType = NormalNode.MappingInformationType\n    const referenceType = NormalNode.ReferenceInformationType\n    const buffer = NormalNode.Normals.a\n    let indexBuffer = []\n    if (referenceType === 'IndexToDirect') {\n      if ('NormalIndex' in NormalNode) {\n        indexBuffer = NormalNode.NormalIndex.a\n      } else if ('NormalsIndex' in NormalNode) {\n        indexBuffer = NormalNode.NormalsIndex.a\n      }\n    }\n\n    return {\n      dataSize: 3,\n      buffer: buffer,\n      indices: indexBuffer,\n      mappingType: mappingType,\n      referenceType: referenceType,\n    }\n  }\n\n  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\n  parseUVs(UVNode) {\n    const mappingType = UVNode.MappingInformationType\n    const referenceType = UVNode.ReferenceInformationType\n    const buffer = UVNode.UV.a\n    let indexBuffer = []\n    if (referenceType === 'IndexToDirect') {\n      indexBuffer = UVNode.UVIndex.a\n    }\n\n    return {\n      dataSize: 2,\n      buffer: buffer,\n      indices: indexBuffer,\n      mappingType: mappingType,\n      referenceType: referenceType,\n    }\n  }\n\n  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\n  parseVertexColors(ColorNode) {\n    const mappingType = ColorNode.MappingInformationType\n    const referenceType = ColorNode.ReferenceInformationType\n    const buffer = ColorNode.Colors.a\n    let indexBuffer = []\n    if (referenceType === 'IndexToDirect') {\n      indexBuffer = ColorNode.ColorIndex.a\n    }\n\n    return {\n      dataSize: 4,\n      buffer: buffer,\n      indices: indexBuffer,\n      mappingType: mappingType,\n      referenceType: referenceType,\n    }\n  }\n\n  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\n  parseMaterialIndices(MaterialNode) {\n    const mappingType = MaterialNode.MappingInformationType\n    const referenceType = MaterialNode.ReferenceInformationType\n\n    if (mappingType === 'NoMappingInformation') {\n      return {\n        dataSize: 1,\n        buffer: [0],\n        indices: [0],\n        mappingType: 'AllSame',\n        referenceType: referenceType,\n      }\n    }\n\n    const materialIndexBuffer = MaterialNode.Materials.a\n\n    // Since materials are stored as indices, there's a bit of a mismatch between FBX and what\n    // we expect.So we create an intermediate buffer that points to the index in the buffer,\n    // for conforming with the other functions we've written for other data.\n    const materialIndices = []\n\n    for (let i = 0; i < materialIndexBuffer.length; ++i) {\n      materialIndices.push(i)\n    }\n\n    return {\n      dataSize: 1,\n      buffer: materialIndexBuffer,\n      indices: materialIndices,\n      mappingType: mappingType,\n      referenceType: referenceType,\n    }\n  }\n\n  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\n  parseNurbsGeometry(geoNode) {\n    if (NURBSCurve === undefined) {\n      console.error(\n        'THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.',\n      )\n      return new BufferGeometry()\n    }\n\n    const order = parseInt(geoNode.Order)\n\n    if (isNaN(order)) {\n      console.error('THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id)\n      return new BufferGeometry()\n    }\n\n    const degree = order - 1\n\n    const knots = geoNode.KnotVector.a\n    const controlPoints = []\n    const pointsValues = geoNode.Points.a\n\n    for (let i = 0, l = pointsValues.length; i < l; i += 4) {\n      controlPoints.push(new Vector4().fromArray(pointsValues, i))\n    }\n\n    let startKnot, endKnot\n\n    if (geoNode.Form === 'Closed') {\n      controlPoints.push(controlPoints[0])\n    } else if (geoNode.Form === 'Periodic') {\n      startKnot = degree\n      endKnot = knots.length - 1 - startKnot\n\n      for (let i = 0; i < degree; ++i) {\n        controlPoints.push(controlPoints[i])\n      }\n    }\n\n    const curve = new NURBSCurve(degree, knots, controlPoints, startKnot, endKnot)\n    const points = curve.getPoints(controlPoints.length * 12)\n\n    return new BufferGeometry().setFromPoints(points)\n  }\n}\n\n// parse animation data from FBXTree\nclass AnimationParser {\n  // take raw animation clips and turn them into three.js animation clips\n  parse() {\n    const animationClips = []\n\n    const rawClips = this.parseClips()\n\n    if (rawClips !== undefined) {\n      for (const key in rawClips) {\n        const rawClip = rawClips[key]\n\n        const clip = this.addClip(rawClip)\n\n        animationClips.push(clip)\n      }\n    }\n\n    return animationClips\n  }\n\n  parseClips() {\n    // since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,\n    // if this is undefined we can safely assume there are no animations\n    if (fbxTree.Objects.AnimationCurve === undefined) return undefined\n\n    const curveNodesMap = this.parseAnimationCurveNodes()\n\n    this.parseAnimationCurves(curveNodesMap)\n\n    const layersMap = this.parseAnimationLayers(curveNodesMap)\n    const rawClips = this.parseAnimStacks(layersMap)\n\n    return rawClips\n  }\n\n  // parse nodes in FBXTree.Objects.AnimationCurveNode\n  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\n  // and is referenced by an AnimationLayer\n  parseAnimationCurveNodes() {\n    const rawCurveNodes = fbxTree.Objects.AnimationCurveNode\n\n    const curveNodesMap = new Map()\n\n    for (const nodeID in rawCurveNodes) {\n      const rawCurveNode = rawCurveNodes[nodeID]\n\n      if (rawCurveNode.attrName.match(/S|R|T|DeformPercent/) !== null) {\n        const curveNode = {\n          id: rawCurveNode.id,\n          attr: rawCurveNode.attrName,\n          curves: {},\n        }\n\n        curveNodesMap.set(curveNode.id, curveNode)\n      }\n    }\n\n    return curveNodesMap\n  }\n\n  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\n  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\n  // axis ( e.g. times and values of x rotation)\n  parseAnimationCurves(curveNodesMap) {\n    const rawCurves = fbxTree.Objects.AnimationCurve\n\n    // TODO: Many values are identical up to roundoff error, but won't be optimised\n    // e.g. position times: [0, 0.4, 0. 8]\n    // position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]\n    // clearly, this should be optimised to\n    // times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]\n    // this shows up in nearly every FBX file, and generally time array is length > 100\n\n    for (const nodeID in rawCurves) {\n      const animationCurve = {\n        id: rawCurves[nodeID].id,\n        times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),\n        values: rawCurves[nodeID].KeyValueFloat.a,\n      }\n\n      const relationships = connections.get(animationCurve.id)\n\n      if (relationships !== undefined) {\n        const animationCurveID = relationships.parents[0].ID\n        const animationCurveRelationship = relationships.parents[0].relationship\n\n        if (animationCurveRelationship.match(/X/)) {\n          curveNodesMap.get(animationCurveID).curves['x'] = animationCurve\n        } else if (animationCurveRelationship.match(/Y/)) {\n          curveNodesMap.get(animationCurveID).curves['y'] = animationCurve\n        } else if (animationCurveRelationship.match(/Z/)) {\n          curveNodesMap.get(animationCurveID).curves['z'] = animationCurve\n        } else if (animationCurveRelationship.match(/d|DeformPercent/) && curveNodesMap.has(animationCurveID)) {\n          curveNodesMap.get(animationCurveID).curves['morph'] = animationCurve\n        }\n      }\n    }\n  }\n\n  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\n  // to various AnimationCurveNodes and is referenced by an AnimationStack node\n  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\n  parseAnimationLayers(curveNodesMap) {\n    const rawLayers = fbxTree.Objects.AnimationLayer\n\n    const layersMap = new Map()\n\n    for (const nodeID in rawLayers) {\n      const layerCurveNodes = []\n\n      const connection = connections.get(parseInt(nodeID))\n\n      if (connection !== undefined) {\n        // all the animationCurveNodes used in the layer\n        const children = connection.children\n\n        children.forEach(function (child, i) {\n          if (curveNodesMap.has(child.ID)) {\n            const curveNode = curveNodesMap.get(child.ID)\n\n            // check that the curves are defined for at least one axis, otherwise ignore the curveNode\n            if (\n              curveNode.curves.x !== undefined ||\n              curveNode.curves.y !== undefined ||\n              curveNode.curves.z !== undefined\n            ) {\n              if (layerCurveNodes[i] === undefined) {\n                const modelID = connections.get(child.ID).parents.filter(function (parent) {\n                  return parent.relationship !== undefined\n                })[0].ID\n\n                if (modelID !== undefined) {\n                  const rawModel = fbxTree.Objects.Model[modelID.toString()]\n\n                  if (rawModel === undefined) {\n                    console.warn('THREE.FBXLoader: Encountered a unused curve.', child)\n                    return\n                  }\n\n                  const node = {\n                    modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : '',\n                    ID: rawModel.id,\n                    initialPosition: [0, 0, 0],\n                    initialRotation: [0, 0, 0],\n                    initialScale: [1, 1, 1],\n                  }\n\n                  sceneGraph.traverse(function (child) {\n                    if (child.ID === rawModel.id) {\n                      node.transform = child.matrix\n\n                      if (child.userData.transformData) node.eulerOrder = child.userData.transformData.eulerOrder\n                    }\n                  })\n\n                  if (!node.transform) node.transform = new Matrix4()\n\n                  // if the animated model is pre rotated, we'll have to apply the pre rotations to every\n                  // animation value as well\n                  if ('PreRotation' in rawModel) node.preRotation = rawModel.PreRotation.value\n                  if ('PostRotation' in rawModel) node.postRotation = rawModel.PostRotation.value\n\n                  layerCurveNodes[i] = node\n                }\n              }\n\n              if (layerCurveNodes[i]) layerCurveNodes[i][curveNode.attr] = curveNode\n            } else if (curveNode.curves.morph !== undefined) {\n              if (layerCurveNodes[i] === undefined) {\n                const deformerID = connections.get(child.ID).parents.filter(function (parent) {\n                  return parent.relationship !== undefined\n                })[0].ID\n\n                const morpherID = connections.get(deformerID).parents[0].ID\n                const geoID = connections.get(morpherID).parents[0].ID\n\n                // assuming geometry is not used in more than one model\n                const modelID = connections.get(geoID).parents[0].ID\n\n                const rawModel = fbxTree.Objects.Model[modelID]\n\n                const node = {\n                  modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : '',\n                  morphName: fbxTree.Objects.Deformer[deformerID].attrName,\n                }\n\n                layerCurveNodes[i] = node\n              }\n\n              layerCurveNodes[i][curveNode.attr] = curveNode\n            }\n          }\n        })\n\n        layersMap.set(parseInt(nodeID), layerCurveNodes)\n      }\n    }\n\n    return layersMap\n  }\n\n  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\n  // hierarchy. Each Stack node will be used to create a AnimationClip\n  parseAnimStacks(layersMap) {\n    const rawStacks = fbxTree.Objects.AnimationStack\n\n    // connect the stacks (clips) up to the layers\n    const rawClips = {}\n\n    for (const nodeID in rawStacks) {\n      const children = connections.get(parseInt(nodeID)).children\n\n      if (children.length > 1) {\n        // it seems like stacks will always be associated with a single layer. But just in case there are files\n        // where there are multiple layers per stack, we'll display a warning\n        console.warn(\n          'THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.',\n        )\n      }\n\n      const layer = layersMap.get(children[0].ID)\n\n      rawClips[nodeID] = {\n        name: rawStacks[nodeID].attrName,\n        layer: layer,\n      }\n    }\n\n    return rawClips\n  }\n\n  addClip(rawClip) {\n    let tracks = []\n\n    const scope = this\n    rawClip.layer.forEach(function (rawTracks) {\n      tracks = tracks.concat(scope.generateTracks(rawTracks))\n    })\n\n    return new AnimationClip(rawClip.name, -1, tracks)\n  }\n\n  generateTracks(rawTracks) {\n    const tracks = []\n\n    let initialPosition = new Vector3()\n    let initialRotation = new Quaternion()\n    let initialScale = new Vector3()\n\n    if (rawTracks.transform) rawTracks.transform.decompose(initialPosition, initialRotation, initialScale)\n\n    initialPosition = initialPosition.toArray()\n    initialRotation = new Euler().setFromQuaternion(initialRotation, rawTracks.eulerOrder).toArray()\n    initialScale = initialScale.toArray()\n\n    if (rawTracks.T !== undefined && Object.keys(rawTracks.T.curves).length > 0) {\n      const positionTrack = this.generateVectorTrack(\n        rawTracks.modelName,\n        rawTracks.T.curves,\n        initialPosition,\n        'position',\n      )\n      if (positionTrack !== undefined) tracks.push(positionTrack)\n    }\n\n    if (rawTracks.R !== undefined && Object.keys(rawTracks.R.curves).length > 0) {\n      const rotationTrack = this.generateRotationTrack(\n        rawTracks.modelName,\n        rawTracks.R.curves,\n        initialRotation,\n        rawTracks.preRotation,\n        rawTracks.postRotation,\n        rawTracks.eulerOrder,\n      )\n      if (rotationTrack !== undefined) tracks.push(rotationTrack)\n    }\n\n    if (rawTracks.S !== undefined && Object.keys(rawTracks.S.curves).length > 0) {\n      const scaleTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, initialScale, 'scale')\n      if (scaleTrack !== undefined) tracks.push(scaleTrack)\n    }\n\n    if (rawTracks.DeformPercent !== undefined) {\n      const morphTrack = this.generateMorphTrack(rawTracks)\n      if (morphTrack !== undefined) tracks.push(morphTrack)\n    }\n\n    return tracks\n  }\n\n  generateVectorTrack(modelName, curves, initialValue, type) {\n    const times = this.getTimesForAllAxes(curves)\n    const values = this.getKeyframeTrackValues(times, curves, initialValue)\n\n    return new VectorKeyframeTrack(modelName + '.' + type, times, values)\n  }\n\n  generateRotationTrack(modelName, curves, initialValue, preRotation, postRotation, eulerOrder) {\n    if (curves.x !== undefined) {\n      this.interpolateRotations(curves.x)\n      curves.x.values = curves.x.values.map(MathUtils.degToRad)\n    }\n\n    if (curves.y !== undefined) {\n      this.interpolateRotations(curves.y)\n      curves.y.values = curves.y.values.map(MathUtils.degToRad)\n    }\n\n    if (curves.z !== undefined) {\n      this.interpolateRotations(curves.z)\n      curves.z.values = curves.z.values.map(MathUtils.degToRad)\n    }\n\n    const times = this.getTimesForAllAxes(curves)\n    const values = this.getKeyframeTrackValues(times, curves, initialValue)\n\n    if (preRotation !== undefined) {\n      preRotation = preRotation.map(MathUtils.degToRad)\n      preRotation.push(eulerOrder)\n\n      preRotation = new Euler().fromArray(preRotation)\n      preRotation = new Quaternion().setFromEuler(preRotation)\n    }\n\n    if (postRotation !== undefined) {\n      postRotation = postRotation.map(MathUtils.degToRad)\n      postRotation.push(eulerOrder)\n\n      postRotation = new Euler().fromArray(postRotation)\n      postRotation = new Quaternion().setFromEuler(postRotation).invert()\n    }\n\n    const quaternion = new Quaternion()\n    const euler = new Euler()\n\n    const quaternionValues = []\n\n    for (let i = 0; i < values.length; i += 3) {\n      euler.set(values[i], values[i + 1], values[i + 2], eulerOrder)\n\n      quaternion.setFromEuler(euler)\n\n      if (preRotation !== undefined) quaternion.premultiply(preRotation)\n      if (postRotation !== undefined) quaternion.multiply(postRotation)\n\n      quaternion.toArray(quaternionValues, (i / 3) * 4)\n    }\n\n    return new QuaternionKeyframeTrack(modelName + '.quaternion', times, quaternionValues)\n  }\n\n  generateMorphTrack(rawTracks) {\n    const curves = rawTracks.DeformPercent.curves.morph\n    const values = curves.values.map(function (val) {\n      return val / 100\n    })\n\n    const morphNum = sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName]\n\n    return new NumberKeyframeTrack(\n      rawTracks.modelName + '.morphTargetInfluences[' + morphNum + ']',\n      curves.times,\n      values,\n    )\n  }\n\n  // For all animated objects, times are defined separately for each axis\n  // Here we'll combine the times into one sorted array without duplicates\n  getTimesForAllAxes(curves) {\n    let times = []\n\n    // first join together the times for each axis, if defined\n    if (curves.x !== undefined) times = times.concat(curves.x.times)\n    if (curves.y !== undefined) times = times.concat(curves.y.times)\n    if (curves.z !== undefined) times = times.concat(curves.z.times)\n\n    // then sort them\n    times = times.sort(function (a, b) {\n      return a - b\n    })\n\n    // and remove duplicates\n    if (times.length > 1) {\n      let targetIndex = 1\n      let lastValue = times[0]\n      for (let i = 1; i < times.length; i++) {\n        const currentValue = times[i]\n        if (currentValue !== lastValue) {\n          times[targetIndex] = currentValue\n          lastValue = currentValue\n          targetIndex++\n        }\n      }\n\n      times = times.slice(0, targetIndex)\n    }\n\n    return times\n  }\n\n  getKeyframeTrackValues(times, curves, initialValue) {\n    const prevValue = initialValue\n\n    const values = []\n\n    let xIndex = -1\n    let yIndex = -1\n    let zIndex = -1\n\n    times.forEach(function (time) {\n      if (curves.x) xIndex = curves.x.times.indexOf(time)\n      if (curves.y) yIndex = curves.y.times.indexOf(time)\n      if (curves.z) zIndex = curves.z.times.indexOf(time)\n\n      // if there is an x value defined for this frame, use that\n      if (xIndex !== -1) {\n        const xValue = curves.x.values[xIndex]\n        values.push(xValue)\n        prevValue[0] = xValue\n      } else {\n        // otherwise use the x value from the previous frame\n        values.push(prevValue[0])\n      }\n\n      if (yIndex !== -1) {\n        const yValue = curves.y.values[yIndex]\n        values.push(yValue)\n        prevValue[1] = yValue\n      } else {\n        values.push(prevValue[1])\n      }\n\n      if (zIndex !== -1) {\n        const zValue = curves.z.values[zIndex]\n        values.push(zValue)\n        prevValue[2] = zValue\n      } else {\n        values.push(prevValue[2])\n      }\n    })\n\n    return values\n  }\n\n  // Rotations are defined as Euler angles which can have values  of any size\n  // These will be converted to quaternions which don't support values greater than\n  // PI, so we'll interpolate large rotations\n  interpolateRotations(curve) {\n    for (let i = 1; i < curve.values.length; i++) {\n      const initialValue = curve.values[i - 1]\n      const valuesSpan = curve.values[i] - initialValue\n\n      const absoluteSpan = Math.abs(valuesSpan)\n\n      if (absoluteSpan >= 180) {\n        const numSubIntervals = absoluteSpan / 180\n\n        const step = valuesSpan / numSubIntervals\n        let nextValue = initialValue + step\n\n        const initialTime = curve.times[i - 1]\n        const timeSpan = curve.times[i] - initialTime\n        const interval = timeSpan / numSubIntervals\n        let nextTime = initialTime + interval\n\n        const interpolatedTimes = []\n        const interpolatedValues = []\n\n        while (nextTime < curve.times[i]) {\n          interpolatedTimes.push(nextTime)\n          nextTime += interval\n\n          interpolatedValues.push(nextValue)\n          nextValue += step\n        }\n\n        curve.times = inject(curve.times, i, interpolatedTimes)\n        curve.values = inject(curve.values, i, interpolatedValues)\n      }\n    }\n  }\n}\n\n// parse an FBX file in ASCII format\nclass TextParser {\n  getPrevNode() {\n    return this.nodeStack[this.currentIndent - 2]\n  }\n\n  getCurrentNode() {\n    return this.nodeStack[this.currentIndent - 1]\n  }\n\n  getCurrentProp() {\n    return this.currentProp\n  }\n\n  pushStack(node) {\n    this.nodeStack.push(node)\n    this.currentIndent += 1\n  }\n\n  popStack() {\n    this.nodeStack.pop()\n    this.currentIndent -= 1\n  }\n\n  setCurrentProp(val, name) {\n    this.currentProp = val\n    this.currentPropName = name\n  }\n\n  parse(text) {\n    this.currentIndent = 0\n\n    this.allNodes = new FBXTree()\n    this.nodeStack = []\n    this.currentProp = []\n    this.currentPropName = ''\n\n    const scope = this\n\n    const split = text.split(/[\\r\\n]+/)\n\n    split.forEach(function (line, i) {\n      const matchComment = line.match(/^[\\s\\t]*;/)\n      const matchEmpty = line.match(/^[\\s\\t]*$/)\n\n      if (matchComment || matchEmpty) return\n\n      const matchBeginning = line.match('^\\\\t{' + scope.currentIndent + '}(\\\\w+):(.*){', '')\n      const matchProperty = line.match('^\\\\t{' + scope.currentIndent + '}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)')\n      const matchEnd = line.match('^\\\\t{' + (scope.currentIndent - 1) + '}}')\n\n      if (matchBeginning) {\n        scope.parseNodeBegin(line, matchBeginning)\n      } else if (matchProperty) {\n        scope.parseNodeProperty(line, matchProperty, split[++i])\n      } else if (matchEnd) {\n        scope.popStack()\n      } else if (line.match(/^[^\\s\\t}]/)) {\n        // large arrays are split over multiple lines terminated with a ',' character\n        // if this is encountered the line needs to be joined to the previous line\n        scope.parseNodePropertyContinued(line)\n      }\n    })\n\n    return this.allNodes\n  }\n\n  parseNodeBegin(line, property) {\n    const nodeName = property[1].trim().replace(/^\"/, '').replace(/\"$/, '')\n\n    const nodeAttrs = property[2].split(',').map(function (attr) {\n      return attr.trim().replace(/^\"/, '').replace(/\"$/, '')\n    })\n\n    const node = { name: nodeName }\n    const attrs = this.parseNodeAttr(nodeAttrs)\n\n    const currentNode = this.getCurrentNode()\n\n    // a top node\n    if (this.currentIndent === 0) {\n      this.allNodes.add(nodeName, node)\n    } else {\n      // a subnode\n\n      // if the subnode already exists, append it\n      if (nodeName in currentNode) {\n        // special case Pose needs PoseNodes as an array\n        if (nodeName === 'PoseNode') {\n          currentNode.PoseNode.push(node)\n        } else if (currentNode[nodeName].id !== undefined) {\n          currentNode[nodeName] = {}\n          currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName]\n        }\n\n        if (attrs.id !== '') currentNode[nodeName][attrs.id] = node\n      } else if (typeof attrs.id === 'number') {\n        currentNode[nodeName] = {}\n        currentNode[nodeName][attrs.id] = node\n      } else if (nodeName !== 'Properties70') {\n        if (nodeName === 'PoseNode') currentNode[nodeName] = [node]\n        else currentNode[nodeName] = node\n      }\n    }\n\n    if (typeof attrs.id === 'number') node.id = attrs.id\n    if (attrs.name !== '') node.attrName = attrs.name\n    if (attrs.type !== '') node.attrType = attrs.type\n\n    this.pushStack(node)\n  }\n\n  parseNodeAttr(attrs) {\n    let id = attrs[0]\n\n    if (attrs[0] !== '') {\n      id = parseInt(attrs[0])\n\n      if (isNaN(id)) {\n        id = attrs[0]\n      }\n    }\n\n    let name = '',\n      type = ''\n\n    if (attrs.length > 1) {\n      name = attrs[1].replace(/^(\\w+)::/, '')\n      type = attrs[2]\n    }\n\n    return { id: id, name: name, type: type }\n  }\n\n  parseNodeProperty(line, property, contentLine) {\n    let propName = property[1].replace(/^\"/, '').replace(/\"$/, '').trim()\n    let propValue = property[2].replace(/^\"/, '').replace(/\"$/, '').trim()\n\n    // for special case: base64 image data follows \"Content: ,\" line\n    //\tContent: ,\n    //\t \"/9j/4RDaRXhpZgAATU0A...\"\n    if (propName === 'Content' && propValue === ',') {\n      propValue = contentLine.replace(/\"/g, '').replace(/,$/, '').trim()\n    }\n\n    const currentNode = this.getCurrentNode()\n    const parentName = currentNode.name\n\n    if (parentName === 'Properties70') {\n      this.parseNodeSpecialProperty(line, propName, propValue)\n      return\n    }\n\n    // Connections\n    if (propName === 'C') {\n      const connProps = propValue.split(',').slice(1)\n      const from = parseInt(connProps[0])\n      const to = parseInt(connProps[1])\n\n      let rest = propValue.split(',').slice(3)\n\n      rest = rest.map(function (elem) {\n        return elem.trim().replace(/^\"/, '')\n      })\n\n      propName = 'connections'\n      propValue = [from, to]\n      append(propValue, rest)\n\n      if (currentNode[propName] === undefined) {\n        currentNode[propName] = []\n      }\n    }\n\n    // Node\n    if (propName === 'Node') currentNode.id = propValue\n\n    // connections\n    if (propName in currentNode && Array.isArray(currentNode[propName])) {\n      currentNode[propName].push(propValue)\n    } else {\n      if (propName !== 'a') currentNode[propName] = propValue\n      else currentNode.a = propValue\n    }\n\n    this.setCurrentProp(currentNode, propName)\n\n    // convert string to array, unless it ends in ',' in which case more will be added to it\n    if (propName === 'a' && propValue.slice(-1) !== ',') {\n      currentNode.a = parseNumberArray(propValue)\n    }\n  }\n\n  parseNodePropertyContinued(line) {\n    const currentNode = this.getCurrentNode()\n\n    currentNode.a += line\n\n    // if the line doesn't end in ',' we have reached the end of the property value\n    // so convert the string to an array\n    if (line.slice(-1) !== ',') {\n      currentNode.a = parseNumberArray(currentNode.a)\n    }\n  }\n\n  // parse \"Property70\"\n  parseNodeSpecialProperty(line, propName, propValue) {\n    // split this\n    // P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1\n    // into array like below\n    // [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ]\n    const props = propValue.split('\",').map(function (prop) {\n      return prop.trim().replace(/^\\\"/, '').replace(/\\s/, '_')\n    })\n\n    const innerPropName = props[0]\n    const innerPropType1 = props[1]\n    const innerPropType2 = props[2]\n    const innerPropFlag = props[3]\n    let innerPropValue = props[4]\n\n    // cast values where needed, otherwise leave as strings\n    switch (innerPropType1) {\n      case 'int':\n      case 'enum':\n      case 'bool':\n      case 'ULongLong':\n      case 'double':\n      case 'Number':\n      case 'FieldOfView':\n        innerPropValue = parseFloat(innerPropValue)\n        break\n\n      case 'Color':\n      case 'ColorRGB':\n      case 'Vector3D':\n      case 'Lcl_Translation':\n      case 'Lcl_Rotation':\n      case 'Lcl_Scaling':\n        innerPropValue = parseNumberArray(innerPropValue)\n        break\n    }\n\n    // CAUTION: these props must append to parent's parent\n    this.getPrevNode()[innerPropName] = {\n      type: innerPropType1,\n      type2: innerPropType2,\n      flag: innerPropFlag,\n      value: innerPropValue,\n    }\n\n    this.setCurrentProp(this.getPrevNode(), innerPropName)\n  }\n}\n\n// Parse an FBX file in Binary format\nclass BinaryParser {\n  parse(buffer) {\n    const reader = new BinaryReader(buffer)\n    reader.skip(23) // skip magic 23 bytes\n\n    const version = reader.getUint32()\n\n    if (version < 6400) {\n      throw new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + version)\n    }\n\n    const allNodes = new FBXTree()\n\n    while (!this.endOfContent(reader)) {\n      const node = this.parseNode(reader, version)\n      if (node !== null) allNodes.add(node.name, node)\n    }\n\n    return allNodes\n  }\n\n  // Check if reader has reached the end of content.\n  endOfContent(reader) {\n    // footer size: 160bytes + 16-byte alignment padding\n    // - 16bytes: magic\n    // - padding til 16-byte alignment (at least 1byte?)\n    //\t(seems like some exporters embed fixed 15 or 16bytes?)\n    // - 4bytes: magic\n    // - 4bytes: version\n    // - 120bytes: zero\n    // - 16bytes: magic\n    if (reader.size() % 16 === 0) {\n      return ((reader.getOffset() + 160 + 16) & ~0xf) >= reader.size()\n    } else {\n      return reader.getOffset() + 160 + 16 >= reader.size()\n    }\n  }\n\n  // recursively parse nodes until the end of the file is reached\n  parseNode(reader, version) {\n    const node = {}\n\n    // The first three data sizes depends on version.\n    const endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32()\n    const numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32()\n\n    version >= 7500 ? reader.getUint64() : reader.getUint32() // the returned propertyListLen is not used\n\n    const nameLen = reader.getUint8()\n    const name = reader.getString(nameLen)\n\n    // Regards this node as NULL-record if endOffset is zero\n    if (endOffset === 0) return null\n\n    const propertyList = []\n\n    for (let i = 0; i < numProperties; i++) {\n      propertyList.push(this.parseProperty(reader))\n    }\n\n    // Regards the first three elements in propertyList as id, attrName, and attrType\n    const id = propertyList.length > 0 ? propertyList[0] : ''\n    const attrName = propertyList.length > 1 ? propertyList[1] : ''\n    const attrType = propertyList.length > 2 ? propertyList[2] : ''\n\n    // check if this node represents just a single property\n    // like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\n    node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false\n\n    while (endOffset > reader.getOffset()) {\n      const subNode = this.parseNode(reader, version)\n\n      if (subNode !== null) this.parseSubNode(name, node, subNode)\n    }\n\n    node.propertyList = propertyList // raw property list used by parent\n\n    if (typeof id === 'number') node.id = id\n    if (attrName !== '') node.attrName = attrName\n    if (attrType !== '') node.attrType = attrType\n    if (name !== '') node.name = name\n\n    return node\n  }\n\n  parseSubNode(name, node, subNode) {\n    // special case: child node is single property\n    if (subNode.singleProperty === true) {\n      const value = subNode.propertyList[0]\n\n      if (Array.isArray(value)) {\n        node[subNode.name] = subNode\n\n        subNode.a = value\n      } else {\n        node[subNode.name] = value\n      }\n    } else if (name === 'Connections' && subNode.name === 'C') {\n      const array = []\n\n      subNode.propertyList.forEach(function (property, i) {\n        // first Connection is FBX type (OO, OP, etc.). We'll discard these\n        if (i !== 0) array.push(property)\n      })\n\n      if (node.connections === undefined) {\n        node.connections = []\n      }\n\n      node.connections.push(array)\n    } else if (subNode.name === 'Properties70') {\n      const keys = Object.keys(subNode)\n\n      keys.forEach(function (key) {\n        node[key] = subNode[key]\n      })\n    } else if (name === 'Properties70' && subNode.name === 'P') {\n      let innerPropName = subNode.propertyList[0]\n      let innerPropType1 = subNode.propertyList[1]\n      const innerPropType2 = subNode.propertyList[2]\n      const innerPropFlag = subNode.propertyList[3]\n      let innerPropValue\n\n      if (innerPropName.indexOf('Lcl ') === 0) innerPropName = innerPropName.replace('Lcl ', 'Lcl_')\n      if (innerPropType1.indexOf('Lcl ') === 0) innerPropType1 = innerPropType1.replace('Lcl ', 'Lcl_')\n\n      if (\n        innerPropType1 === 'Color' ||\n        innerPropType1 === 'ColorRGB' ||\n        innerPropType1 === 'Vector' ||\n        innerPropType1 === 'Vector3D' ||\n        innerPropType1.indexOf('Lcl_') === 0\n      ) {\n        innerPropValue = [subNode.propertyList[4], subNode.propertyList[5], subNode.propertyList[6]]\n      } else {\n        innerPropValue = subNode.propertyList[4]\n      }\n\n      // this will be copied to parent, see above\n      node[innerPropName] = {\n        type: innerPropType1,\n        type2: innerPropType2,\n        flag: innerPropFlag,\n        value: innerPropValue,\n      }\n    } else if (node[subNode.name] === undefined) {\n      if (typeof subNode.id === 'number') {\n        node[subNode.name] = {}\n        node[subNode.name][subNode.id] = subNode\n      } else {\n        node[subNode.name] = subNode\n      }\n    } else {\n      if (subNode.name === 'PoseNode') {\n        if (!Array.isArray(node[subNode.name])) {\n          node[subNode.name] = [node[subNode.name]]\n        }\n\n        node[subNode.name].push(subNode)\n      } else if (node[subNode.name][subNode.id] === undefined) {\n        node[subNode.name][subNode.id] = subNode\n      }\n    }\n  }\n\n  parseProperty(reader) {\n    const type = reader.getString(1)\n    let length\n\n    switch (type) {\n      case 'C':\n        return reader.getBoolean()\n\n      case 'D':\n        return reader.getFloat64()\n\n      case 'F':\n        return reader.getFloat32()\n\n      case 'I':\n        return reader.getInt32()\n\n      case 'L':\n        return reader.getInt64()\n\n      case 'R':\n        length = reader.getUint32()\n        return reader.getArrayBuffer(length)\n\n      case 'S':\n        length = reader.getUint32()\n        return reader.getString(length)\n\n      case 'Y':\n        return reader.getInt16()\n\n      case 'b':\n      case 'c':\n      case 'd':\n      case 'f':\n      case 'i':\n      case 'l':\n        const arrayLength = reader.getUint32()\n        const encoding = reader.getUint32() // 0: non-compressed, 1: compressed\n        const compressedLength = reader.getUint32()\n\n        if (encoding === 0) {\n          switch (type) {\n            case 'b':\n            case 'c':\n              return reader.getBooleanArray(arrayLength)\n\n            case 'd':\n              return reader.getFloat64Array(arrayLength)\n\n            case 'f':\n              return reader.getFloat32Array(arrayLength)\n\n            case 'i':\n              return reader.getInt32Array(arrayLength)\n\n            case 'l':\n              return reader.getInt64Array(arrayLength)\n          }\n        }\n\n        const data = unzlibSync(new Uint8Array(reader.getArrayBuffer(compressedLength)))\n        const reader2 = new BinaryReader(data.buffer)\n\n        switch (type) {\n          case 'b':\n          case 'c':\n            return reader2.getBooleanArray(arrayLength)\n\n          case 'd':\n            return reader2.getFloat64Array(arrayLength)\n\n          case 'f':\n            return reader2.getFloat32Array(arrayLength)\n\n          case 'i':\n            return reader2.getInt32Array(arrayLength)\n\n          case 'l':\n            return reader2.getInt64Array(arrayLength)\n        }\n\n      default:\n        throw new Error('THREE.FBXLoader: Unknown property type ' + type)\n    }\n  }\n}\n\nclass BinaryReader {\n  constructor(buffer, littleEndian) {\n    this.dv = new DataView(buffer)\n    this.offset = 0\n    this.littleEndian = littleEndian !== undefined ? littleEndian : true\n  }\n\n  getOffset() {\n    return this.offset\n  }\n\n  size() {\n    return this.dv.buffer.byteLength\n  }\n\n  skip(length) {\n    this.offset += length\n  }\n\n  // seems like true/false representation depends on exporter.\n  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\n  // then sees LSB.\n  getBoolean() {\n    return (this.getUint8() & 1) === 1\n  }\n\n  getBooleanArray(size) {\n    const a = []\n\n    for (let i = 0; i < size; i++) {\n      a.push(this.getBoolean())\n    }\n\n    return a\n  }\n\n  getUint8() {\n    const value = this.dv.getUint8(this.offset)\n    this.offset += 1\n    return value\n  }\n\n  getInt16() {\n    const value = this.dv.getInt16(this.offset, this.littleEndian)\n    this.offset += 2\n    return value\n  }\n\n  getInt32() {\n    const value = this.dv.getInt32(this.offset, this.littleEndian)\n    this.offset += 4\n    return value\n  }\n\n  getInt32Array(size) {\n    const a = []\n\n    for (let i = 0; i < size; i++) {\n      a.push(this.getInt32())\n    }\n\n    return a\n  }\n\n  getUint32() {\n    const value = this.dv.getUint32(this.offset, this.littleEndian)\n    this.offset += 4\n    return value\n  }\n\n  // JavaScript doesn't support 64-bit integer so calculate this here\n  // 1 << 32 will return 1 so using multiply operation instead here.\n  // There's a possibility that this method returns wrong value if the value\n  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\n  // TODO: safely handle 64-bit integer\n  getInt64() {\n    let low, high\n\n    if (this.littleEndian) {\n      low = this.getUint32()\n      high = this.getUint32()\n    } else {\n      high = this.getUint32()\n      low = this.getUint32()\n    }\n\n    // calculate negative value\n    if (high & 0x80000000) {\n      high = ~high & 0xffffffff\n      low = ~low & 0xffffffff\n\n      if (low === 0xffffffff) high = (high + 1) & 0xffffffff\n\n      low = (low + 1) & 0xffffffff\n\n      return -(high * 0x100000000 + low)\n    }\n\n    return high * 0x100000000 + low\n  }\n\n  getInt64Array(size) {\n    const a = []\n\n    for (let i = 0; i < size; i++) {\n      a.push(this.getInt64())\n    }\n\n    return a\n  }\n\n  // Note: see getInt64() comment\n  getUint64() {\n    let low, high\n\n    if (this.littleEndian) {\n      low = this.getUint32()\n      high = this.getUint32()\n    } else {\n      high = this.getUint32()\n      low = this.getUint32()\n    }\n\n    return high * 0x100000000 + low\n  }\n\n  getFloat32() {\n    const value = this.dv.getFloat32(this.offset, this.littleEndian)\n    this.offset += 4\n    return value\n  }\n\n  getFloat32Array(size) {\n    const a = []\n\n    for (let i = 0; i < size; i++) {\n      a.push(this.getFloat32())\n    }\n\n    return a\n  }\n\n  getFloat64() {\n    const value = this.dv.getFloat64(this.offset, this.littleEndian)\n    this.offset += 8\n    return value\n  }\n\n  getFloat64Array(size) {\n    const a = []\n\n    for (let i = 0; i < size; i++) {\n      a.push(this.getFloat64())\n    }\n\n    return a\n  }\n\n  getArrayBuffer(size) {\n    const value = this.dv.buffer.slice(this.offset, this.offset + size)\n    this.offset += size\n    return value\n  }\n\n  getString(size) {\n    // note: safari 9 doesn't support Uint8Array.indexOf; create intermediate array instead\n    let a = []\n\n    for (let i = 0; i < size; i++) {\n      a[i] = this.getUint8()\n    }\n\n    const nullByte = a.indexOf(0)\n    if (nullByte >= 0) a = a.slice(0, nullByte)\n\n    return decodeText(new Uint8Array(a))\n  }\n}\n\n// FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)\n// and BinaryParser( FBX Binary format)\nclass FBXTree {\n  add(key, val) {\n    this[key] = val\n  }\n}\n\n// ************** UTILITY FUNCTIONS **************\n\nfunction isFbxFormatBinary(buffer) {\n  const CORRECT = 'Kaydara\\u0020FBX\\u0020Binary\\u0020\\u0020\\0'\n\n  return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length)\n}\n\nfunction isFbxFormatASCII(text) {\n  const CORRECT = [\n    'K',\n    'a',\n    'y',\n    'd',\n    'a',\n    'r',\n    'a',\n    '\\\\',\n    'F',\n    'B',\n    'X',\n    '\\\\',\n    'B',\n    'i',\n    'n',\n    'a',\n    'r',\n    'y',\n    '\\\\',\n    '\\\\',\n  ]\n\n  let cursor = 0\n\n  function read(offset) {\n    const result = text[offset - 1]\n    text = text.slice(cursor + offset)\n    cursor++\n    return result\n  }\n\n  for (let i = 0; i < CORRECT.length; ++i) {\n    const num = read(1)\n    if (num === CORRECT[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction getFbxVersion(text) {\n  const versionRegExp = /FBXVersion: (\\d+)/\n  const match = text.match(versionRegExp)\n\n  if (match) {\n    const version = parseInt(match[1])\n    return version\n  }\n\n  throw new Error('THREE.FBXLoader: Cannot find the version number for the file given.')\n}\n\n// Converts FBX ticks into real time seconds.\nfunction convertFBXTimeToSeconds(time) {\n  return time / 46186158000\n}\n\nconst dataArray = []\n\n// extracts the data from the correct position in the FBX array based on indexing type\nfunction getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n  let index\n\n  switch (infoObject.mappingType) {\n    case 'ByPolygonVertex':\n      index = polygonVertexIndex\n      break\n    case 'ByPolygon':\n      index = polygonIndex\n      break\n    case 'ByVertice':\n      index = vertexIndex\n      break\n    case 'AllSame':\n      index = infoObject.indices[0]\n      break\n    default:\n      console.warn('THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType)\n  }\n\n  if (infoObject.referenceType === 'IndexToDirect') index = infoObject.indices[index]\n\n  const from = index * infoObject.dataSize\n  const to = from + infoObject.dataSize\n\n  return slice(dataArray, infoObject.buffer, from, to)\n}\n\nconst tempEuler = /* @__PURE__ */ new Euler()\nconst tempVec = /* @__PURE__ */ new Vector3()\n\n// generate transformation from FBX transform data\n// ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm\n// ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e\nfunction generateTransform(transformData) {\n  const lTranslationM = new Matrix4()\n  const lPreRotationM = new Matrix4()\n  const lRotationM = new Matrix4()\n  const lPostRotationM = new Matrix4()\n\n  const lScalingM = new Matrix4()\n  const lScalingPivotM = new Matrix4()\n  const lScalingOffsetM = new Matrix4()\n  const lRotationOffsetM = new Matrix4()\n  const lRotationPivotM = new Matrix4()\n\n  const lParentGX = new Matrix4()\n  const lParentLX = new Matrix4()\n  const lGlobalT = new Matrix4()\n\n  const inheritType = transformData.inheritType ? transformData.inheritType : 0\n\n  if (transformData.translation) lTranslationM.setPosition(tempVec.fromArray(transformData.translation))\n\n  if (transformData.preRotation) {\n    const array = transformData.preRotation.map(MathUtils.degToRad)\n    array.push(transformData.eulerOrder)\n    lPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array))\n  }\n\n  if (transformData.rotation) {\n    const array = transformData.rotation.map(MathUtils.degToRad)\n    array.push(transformData.eulerOrder)\n    lRotationM.makeRotationFromEuler(tempEuler.fromArray(array))\n  }\n\n  if (transformData.postRotation) {\n    const array = transformData.postRotation.map(MathUtils.degToRad)\n    array.push(transformData.eulerOrder)\n    lPostRotationM.makeRotationFromEuler(tempEuler.fromArray(array))\n    lPostRotationM.invert()\n  }\n\n  if (transformData.scale) lScalingM.scale(tempVec.fromArray(transformData.scale))\n\n  // Pivots and offsets\n  if (transformData.scalingOffset) lScalingOffsetM.setPosition(tempVec.fromArray(transformData.scalingOffset))\n  if (transformData.scalingPivot) lScalingPivotM.setPosition(tempVec.fromArray(transformData.scalingPivot))\n  if (transformData.rotationOffset) lRotationOffsetM.setPosition(tempVec.fromArray(transformData.rotationOffset))\n  if (transformData.rotationPivot) lRotationPivotM.setPosition(tempVec.fromArray(transformData.rotationPivot))\n\n  // parent transform\n  if (transformData.parentMatrixWorld) {\n    lParentLX.copy(transformData.parentMatrix)\n    lParentGX.copy(transformData.parentMatrixWorld)\n  }\n\n  const lLRM = lPreRotationM.clone().multiply(lRotationM).multiply(lPostRotationM)\n  // Global Rotation\n  const lParentGRM = new Matrix4()\n  lParentGRM.extractRotation(lParentGX)\n\n  // Global Shear*Scaling\n  const lParentTM = new Matrix4()\n  lParentTM.copyPosition(lParentGX)\n\n  const lParentGRSM = lParentTM.clone().invert().multiply(lParentGX)\n  const lParentGSM = lParentGRM.clone().invert().multiply(lParentGRSM)\n  const lLSM = lScalingM\n\n  const lGlobalRS = new Matrix4()\n\n  if (inheritType === 0) {\n    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM).multiply(lLSM)\n  } else if (inheritType === 1) {\n    lGlobalRS.copy(lParentGRM).multiply(lParentGSM).multiply(lLRM).multiply(lLSM)\n  } else {\n    const lParentLSM = new Matrix4().scale(new Vector3().setFromMatrixScale(lParentLX))\n    const lParentLSM_inv = lParentLSM.clone().invert()\n    const lParentGSM_noLocal = lParentGSM.clone().multiply(lParentLSM_inv)\n\n    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM_noLocal).multiply(lLSM)\n  }\n\n  const lRotationPivotM_inv = lRotationPivotM.clone().invert()\n  const lScalingPivotM_inv = lScalingPivotM.clone().invert()\n  // Calculate the local transform matrix\n  let lTransform = lTranslationM\n    .clone()\n    .multiply(lRotationOffsetM)\n    .multiply(lRotationPivotM)\n    .multiply(lPreRotationM)\n    .multiply(lRotationM)\n    .multiply(lPostRotationM)\n    .multiply(lRotationPivotM_inv)\n    .multiply(lScalingOffsetM)\n    .multiply(lScalingPivotM)\n    .multiply(lScalingM)\n    .multiply(lScalingPivotM_inv)\n\n  const lLocalTWithAllPivotAndOffsetInfo = new Matrix4().copyPosition(lTransform)\n\n  const lGlobalTranslation = lParentGX.clone().multiply(lLocalTWithAllPivotAndOffsetInfo)\n  lGlobalT.copyPosition(lGlobalTranslation)\n\n  lTransform = lGlobalT.clone().multiply(lGlobalRS)\n\n  // from global to local\n  lTransform.premultiply(lParentGX.invert())\n\n  return lTransform\n}\n\n// Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order\n// ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html\nfunction getEulerOrder(order) {\n  order = order || 0\n\n  const enums = [\n    'ZYX', // -> XYZ extrinsic\n    'YZX', // -> XZY extrinsic\n    'XZY', // -> YZX extrinsic\n    'ZXY', // -> YXZ extrinsic\n    'YXZ', // -> ZXY extrinsic\n    'XYZ', // -> ZYX extrinsic\n    //'SphericXYZ', // not possible to support\n  ]\n\n  if (order === 6) {\n    console.warn('THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.')\n    return enums[0]\n  }\n\n  return enums[order]\n}\n\n// Parses comma separated list of numbers and returns them an array.\n// Used internally by the TextParser\nfunction parseNumberArray(value) {\n  const array = value.split(',').map(function (val) {\n    return parseFloat(val)\n  })\n\n  return array\n}\n\nfunction convertArrayBufferToString(buffer, from, to) {\n  if (from === undefined) from = 0\n  if (to === undefined) to = buffer.byteLength\n\n  return decodeText(new Uint8Array(buffer, from, to))\n}\n\nfunction append(a, b) {\n  for (let i = 0, j = a.length, l = b.length; i < l; i++, j++) {\n    a[j] = b[i]\n  }\n}\n\nfunction slice(a, b, from, to) {\n  for (let i = from, j = 0; i < to; i++, j++) {\n    a[j] = b[i]\n  }\n\n  return a\n}\n\n// inject array a2 into array a1 at index\nfunction inject(a1, index, a2) {\n  return a1.slice(0, index).concat(a2).concat(a1.slice(index))\n}\n\nexport { FBXLoader }\n"],"names":["child","material","skeleton"],"mappings":"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","ignoreList":[0],"debugId":null}}]
}